<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>マルチプレイトランプゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            overscroll-behavior: none; /* スワイプでのページの戻る/進むを無効化 */
            touch-action: manipulation; /* ダブルタップズームを無効化 */
        }
        .screen { display: none; }
        .screen.active { display: flex; flex-direction: column; }
        
        /* カードのスタイル */
        .card {
            width: 70px;
            height: 98px;
            border-radius: 6px;
            background-color: white;
            border: 1px solid #B0B0B0;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            position: relative;
            user-select: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 4px 8px 10px rgba(0,0,0,0.2); }
        .card.red { color: #D92D20; }
        .card.black { color: #101828; }
        .card .rank { position: absolute; top: 4px; left: 6px; font-size: 14px; }
        .card .suit { font-size: 28px; }
        .card .suit-sm { position: absolute; bottom: 4px; right: 6px; font-size: 14px; transform: rotate(180deg); }
        .card.back {
            background-image:
                linear-gradient(45deg, #4477ff 25%, transparent 25%),
                linear-gradient(-45deg, #4477ff 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #4477ff 75%),
                linear-gradient(-45deg, transparent 75%, #4477ff 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #3366ee;
        }
        .card.selected, .card.hovered { transform: translateY(-15px); border: 2px solid #3b82f6; }
        .card.disabled { opacity: 0.5; cursor: not-allowed; }
        .card.matched { visibility: hidden; }
        
        /* 手札のレイアウト */
        #my-hand-area-cards {
            display: flex;
            flex-wrap: nowrap; /* スマホで手札が折り返さないように */
            overflow-x: auto; /* 横スクロールを可能に */
            justify-content: flex-start; /* 左詰め */
            align-items: center;
            padding: 10px;
            -webkit-overflow-scrolling: touch; /* iOSでの慣性スクロール */
        }
        #my-hand-area-cards .card {
            flex-shrink: 0; /* カードが縮まないように */
            margin-left: -30px;
        }
        #my-hand-area-cards .card:first-child { margin-left: 0; }

        .opponent-card-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .opponent-card-container.interactive .card {
            margin: 0 -15px 0 0 !important;
        }
        
        #table-area.grid-layout {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(65px, 1fr));
            gap: 8px;
            padding: 8px;
            width: 100%;
            height: 100%;
            overflow-y: auto;
        }
        #table-area.grid-layout .card {
            width: 100%;
            height: 80px; /* Adjust height for grid */
        }
    </style>
</head>
<body class="bg-gray-100 antialiased">

    <div id="app-container" class="max-w-md mx-auto min-h-screen bg-white shadow-lg">

        <!-- ===== ホーム画面 ===== -->
        <div id="home-screen" class="screen active p-6">
            <header class="text-center mb-8">
                <h1 class="text-3xl font-bold text-gray-800">トランプゲーム</h1>
                <p class="text-gray-500 mt-2">遊びたいゲームを選んでください</p>
            </header>
            <div class="space-y-4">
                <button data-game="daifugo" class="game-select-btn w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">大富豪</button>
                <button data-game="babanuki" class="game-select-btn w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">ばば抜き</button>
                <button data-game="shinkeisuijaku" class="game-select-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">神経衰弱</button>
                <button data-game="doubt" class="game-select-btn w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">ダウト</button>
            </div>
             <div class="mt-8 text-center">
                <p class="text-sm text-gray-400">あなたのID:</p>
                <p id="user-id-display" class="text-xs text-gray-500 bg-gray-100 p-2 rounded break-all"></p>
            </div>
        </div>

        <!-- ===== ロビー画面 ===== -->
        <div id="lobby-screen" class="screen p-6">
            <header class="text-center mb-6 relative">
                <h1 id="lobby-title" class="text-2xl font-bold text-gray-800"></h1>
                <button id="back-to-home-btn" class="absolute top-0 left-0 text-gray-500 hover:text-gray-800 p-2">&larr; 戻る</button>
                <p class="text-gray-500 mt-1">友達とコードを共有して参加者を集めよう</p>
            </header>
            <div id="join-create-section">
                <div class="space-y-4">
                     <button id="create-game-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">新しいルームを作成</button>
                    <div class="relative flex items-center justify-center text-gray-400"><span class="px-2 bg-white">または</span></div>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="join-code-input" placeholder="共有コードを入力" class="flex-grow w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <button id="join-game-btn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-3 px-4 rounded-lg shadow-md">参加</button>
                    </div>
                </div>
                <!-- 大富豪ローカルルール設定 -->
                <div id="daifugo-rules-section" class="hidden mt-6 p-4 border rounded-lg bg-gray-50">
                    <h3 class="font-bold mb-3 text-gray-800 flex justify-between items-center">
                        <span>大富豪ローカルルール設定</span>
                        <button id="rule-info-btn" class="text-sm text-blue-500 hover:underline">ルール説明</button>
                    </h3>
                    <div id="daifugo-rules-list" class="space-y-2 text-sm text-gray-700 grid grid-cols-2 gap-x-4 gap-y-2">
                        <!-- ルールチェックボックスがJSでここに追加されます -->
                    </div>
                </div>
            </div>
            <div id="waiting-room-section" class="hidden">
                <div class="text-center mb-6">
                    <p class="text-gray-600">共有コード</p>
                    <div class="bg-gray-100 p-4 rounded-lg mt-2 flex items-center justify-center">
                        <p id="share-code-display" class="text-3xl font-bold tracking-widest text-gray-800"></p>
                        <button id="copy-code-btn" class="ml-4 p-2 rounded-lg bg-gray-200 hover:bg-gray-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                    </div>
                </div>
                <div class="mb-6"><h2 class="text-xl font-bold text-gray-700 mb-3">参加者</h2><div id="player-list" class="space-y-2"></div></div>
                <div class="mt-8 space-y-4">
                     <button id="start-game-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">ゲーム開始</button>
                    <button id="leave-game-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg shadow-md">ルームを抜ける</button>
                </div>
            </div>
        </div>

        <!-- ===== ゲーム画面 ===== -->
        <div id="game-screen" class="screen p-2 md:p-4 bg-green-800 min-h-screen text-white">
            <div id="game-header" class="flex justify-between items-center mb-2 p-2 bg-black bg-opacity-20 rounded-lg">
                <h2 id="game-title" class="text-xl font-bold"></h2>
                <button id="leave-game-ingame-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg text-sm">ルーム退出</button>
            </div>
            <div id="opponents-area" class="flex justify-around items-start flex-wrap gap-2 mb-2 min-h-[100px]"></div>
            <div id="table-area" class="flex-grow flex flex-col items-center justify-center bg-green-700 rounded-lg p-2 shadow-inner mb-2 relative min-h-[140px]"></div>
            <div id="my-info-area" class="flex flex-col items-center justify-center">
                <div id="my-hand-area-cards" class="w-full min-h-[120px]"></div>
                <div id="game-actions-area" class="mt-2 h-10"></div>
            </div>
            <div id="game-status-message" class="text-center font-semibold p-2 bg-black bg-opacity-30 rounded-lg mt-2"></div>
        </div>

        <!-- ===== メッセージ表示用モーダル ===== -->
        <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-sm w-11/12 text-center">
                <p id="message-text" class="text-lg text-gray-800"></p>
                <button id="close-message-btn" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">OK</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, arrayUnion, arrayRemove, writeBatch, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- 定数と設定 ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyDrgRoyNxnXHia1ASG1dup-hm2p4D0IpGw",
            authDomain: "card-game-platform-f967a.firebaseapp.com",
            projectId: "card-game-platform-f967a",
            storageBucket: "card-game-platform-f967a.firebasestorage.app",
            messagingSenderId: "165676867683",
            appId: "1:165676867683:web:dfd9677b260edf12161856",
            measurementId: "G-HK9L7PR991"
        };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-card-game-app';
        const GAME_NAMES = { daifugo: "大富豪", babanuki: "ばば抜き", shinkeisuijaku: "神経衰弱", doubt: "ダウト" };
        const MIN_PLAYERS = { daifugo: 2, babanuki: 2, shinkeisuijaku: 2, doubt: 2 };
        const MAX_PLAYERS = { daifugo: 6, babanuki: 8, shinkeisuijaku: 6, doubt: 8 };
        const SUITS = ['H', 'D', 'C', 'S'];
        const RANKS = Array.from({ length: 13 }, (_, i) => i + 1); // 1(A) to 13(K)
        const RANK_DISPLAY_MAP = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K' };
        const DAIFUGO_RULES = {
            eightCut: { label: "8切り", default: true, description: "8を出すと場が流れます。" },
            elevenBack: { label: "11バック", default: true, description: "J(11)を出すとカードの強さが一時的に逆転します。" },
            shibari: { label: "しばり", default: true, description: "前の人と同じスートのカードが続くと、以降そのスートしか出せなくなります。" },
            revolution: { label: "革命", default: true, description: "同じ数字4枚以上でカードの強さが永続的に逆転します。" },
            sevenPass: { label: "7渡し", default: false, description: "出した7の枚数分、次の人に手札を渡せます。" },
            tenDiscard: { label: "10捨て", default: false, description: "出した10の枚数分、手札を捨てられます。" },
        };

        // --- グローバル変数 ---
        let app, auth, db;
        let userId, userDisplayName;
        let currentGameId = null;
        let selectedGameType = null;
        let gameUnsubscribe = null;
        let localGameState = {};
        let clientSideTimer = null;

        // --- DOM要素 ---
        const screens = { home: document.getElementById('home-screen'), lobby: document.getElementById('lobby-screen'), game: document.getElementById('game-screen') };
        const allDomElements = {
            userIdDisplay: document.getElementById('user-id-display'),
            lobbyTitle: document.getElementById('lobby-title'),
            createGameBtn: document.getElementById('create-game-btn'),
            joinCodeInput: document.getElementById('join-code-input'),
            joinGameBtn: document.getElementById('join-game-btn'),
            joinCreateSection: document.getElementById('join-create-section'),
            waitingRoomSection: document.getElementById('waiting-room-section'),
            shareCodeDisplay: document.getElementById('share-code-display'),
            playerList: document.getElementById('player-list'),
            startGameBtn: document.getElementById('start-game-btn'),
            leaveGameBtn: document.getElementById('leave-game-btn'),
            copyCodeBtn: document.getElementById('copy-code-btn'),
            messageModal: document.getElementById('message-modal'),
            messageText: document.getElementById('message-text'),
            closeMessageBtn: document.getElementById('close-message-btn'),
            backToHomeBtn: document.getElementById('back-to-home-btn'),
            daifugoRulesSection: document.getElementById('daifugo-rules-section'),
            daifugoRulesList: document.getElementById('daifugo-rules-list'),
            ruleInfoBtn: document.getElementById('rule-info-btn'),
            gameTitle: document.getElementById('game-title'),
            leaveGameIngameBtn: document.getElementById('leave-game-ingame-btn'),
            opponentsArea: document.getElementById('opponents-area'),
            tableArea: document.getElementById('table-area'),
            myHandAreaCards: document.getElementById('my-hand-area-cards'),
            gameActionsArea: document.getElementById('game-actions-area'),
            gameStatusMessage: document.getElementById('game-status-message'),
        };

        // --- 初期化 & 認証 ---
        async function initialize() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            onAuthStateChanged(auth, user => handleAuthState(user));
            setupEventListeners();
            setupDaifugoRules();
        }

        async function handleAuthState(user) {
            if (user) {
                userId = user.uid;
                userDisplayName = `Player-${userId.substring(0, 4)}`;
                allDomElements.userIdDisplay.textContent = userId;
            } else {
                try {
                    await (typeof __initial_auth_token !== 'undefined' && __initial_auth_token
                        ? signInWithCustomToken(auth, __initial_auth_token)
                        : signInAnonymously(auth));
                } catch (error) { console.error("Authentication failed:", error); showMessage("認証に失敗しました。"); }
            }
        }

        // --- イベントリスナー設定 ---
        function setupEventListeners() {
            document.querySelectorAll('.game-select-btn').forEach(btn => btn.addEventListener('click', handleGameSelect));
            allDomElements.createGameBtn.addEventListener('click', createGame);
            allDomElements.joinGameBtn.addEventListener('click', joinGame);
            allDomElements.leaveGameBtn.addEventListener('click', leaveGame);
            allDomElements.leaveGameIngameBtn.addEventListener('click', leaveGame);
            allDomElements.startGameBtn.addEventListener('click', startGame);
            allDomElements.copyCodeBtn.addEventListener('click', copyShareCode);
            allDomElements.closeMessageBtn.addEventListener('click', () => allDomElements.messageModal.classList.add('hidden'));
            allDomElements.backToHomeBtn.addEventListener('click', resetLobby);
            allDomElements.ruleInfoBtn.addEventListener('click', showDaifugoRuleInfo);
        }
        
        // --- 画面遷移 & UIヘルパー ---
        const showScreen = (screenName) => { Object.values(screens).forEach(s => s.classList.remove('active')); screens[screenName].classList.add('active'); };
        const showMessage = (message, isHtml = false) => { 
            if(isHtml) allDomElements.messageText.innerHTML = message;
            else allDomElements.messageText.textContent = message;
            allDomElements.messageModal.classList.remove('hidden'); 
        };
        const generateGameId = () => Array(6).fill(0).map(() => 'ABCDEFGHIJKLMNPQRSTUVWXYZ123456789'[Math.floor(Math.random() * 35)]).join('');

        // --- ホーム画面ロジック ---
        function handleGameSelect(e) {
            if (!auth.currentUser) return showMessage("ユーザー情報が読み込まれていません。");
            selectedGameType = e.currentTarget.dataset.game;
            allDomElements.lobbyTitle.textContent = `${GAME_NAMES[selectedGameType]} のロビー`;
            allDomElements.daifugoRulesSection.classList.toggle('hidden', selectedGameType !== 'daifugo');
            showScreen('lobby');
        }

        // --- 大富豪ルール設定 ---
        function setupDaifugoRules() {
            const listEl = allDomElements.daifugoRulesList;
            listEl.innerHTML = '';
            for (const ruleKey in DAIFUGO_RULES) {
                const rule = DAIFUGO_RULES[ruleKey];
                const labelEl = document.createElement('label');
                labelEl.className = 'flex items-center space-x-2 cursor-pointer';
                labelEl.innerHTML = `<input type="checkbox" name="${ruleKey}" ${rule.default ? 'checked' : ''} class="rounded text-blue-500 focus:ring-blue-500"><span>${rule.label}</span>`;
                listEl.appendChild(labelEl);
            }
        }
        function getSelectedDaifugoRules() {
            const rules = {};
            document.querySelectorAll('#daifugo-rules-list input[type="checkbox"]').forEach(checkbox => { rules[checkbox.name] = checkbox.checked; });
            return rules;
        }
        function showDaifugoRuleInfo() {
            let infoText = '<ul class="text-left list-disc pl-5 space-y-2">';
            for(const key in DAIFUGO_RULES) { infoText += `<li><strong>${DAIFUGO_RULES[key].label}:</strong> ${DAIFUGO_RULES[key].description}</li>`; }
            infoText += '</ul>';
            showMessage(infoText, true);
        }

        // --- ロビーロジック ---
        async function createGame() {
            const gameId = generateGameId(); currentGameId = gameId;
            const hostPlayer = { id: userId, name: userDisplayName, isHost: true, rank: 'heimin' };
            const gameDoc = { gameType: selectedGameType, hostId: userId, players: [hostPlayer], status: 'waiting', createdAt: new Date() };
            if (selectedGameType === 'daifugo') gameDoc.rules = getSelectedDaifugoRules();
            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
                await setDoc(gameRef, gameDoc);
                listenToGameUpdates(gameId);
                allDomElements.joinCreateSection.classList.add('hidden'); allDomElements.waitingRoomSection.classList.remove('hidden');
            } catch (error) { console.error("Error creating game:", error); showMessage("ゲームの作成に失敗しました。"); }
        }

        async function joinGame() {
            const gameId = allDomElements.joinCodeInput.value.toUpperCase().trim();
            if (!gameId) return showMessage("共有コードを入力してください。");
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
            try {
                const gameDoc = await getDoc(gameRef); if (!gameDoc.exists()) return showMessage("ルームが見つかりません。");
                const gameData = gameDoc.data(); if (gameData.status !== 'waiting') return showMessage("このゲームは既に参加できません。");
                if (gameData.players.length >= MAX_PLAYERS[gameData.gameType]) return showMessage("このルームは満員です。");
                if (!gameData.players.some(p => p.id === userId)) {
                    const newPlayer = { id: userId, name: userDisplayName, isHost: false, rank: 'heimin' };
                    await updateDoc(gameRef, { players: arrayUnion(newPlayer) });
                }
                currentGameId = gameId; selectedGameType = gameData.gameType;
                listenToGameUpdates(gameId);
                allDomElements.lobbyTitle.textContent = `${GAME_NAMES[selectedGameType]} のロビー`;
                allDomElements.daifugoRulesSection.classList.toggle('hidden', selectedGameType !== 'daifugo');
                allDomElements.joinCreateSection.classList.add('hidden'); allDomElements.waitingRoomSection.classList.remove('hidden');
            } catch (error) { console.error("Error joining game:", error); showMessage("ゲームへの参加に失敗しました。"); }
        }
        
        async function leaveGame() {
            if (!currentGameId || !userId) return;
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef); if (!gameDoc.exists()) return;
                    let gameData = gameDoc.data();
                    const remainingPlayers = gameData.players.filter(p => p.id !== userId);
                    if (remainingPlayers.length === 0) { transaction.delete(gameRef); }
                    else {
                        if (gameData.hostId === userId) { remainingPlayers[0].isHost = true; gameData.hostId = remainingPlayers[0].id; }
                        gameData.players = remainingPlayers;
                        if(gameData.status === 'playing') {
                           const logic = gameLogics[gameData.gameType];
                           if(logic?.handleLeave) gameData = logic.handleLeave(gameData, userId);
                        }
                        transaction.update(gameRef, gameData);
                    }
                });
            } catch (error) { console.error("Error leaving game:", error); }
            finally { resetLobby(); }
        }
        
        function resetLobby() {
            if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
            currentGameId = null; localGameState = {}; allDomElements.joinCodeInput.value = '';
            allDomElements.waitingRoomSection.classList.add('hidden'); allDomElements.joinCreateSection.classList.remove('hidden');
            showScreen('home');
        }

        function listenToGameUpdates(gameId) {
            if (gameUnsubscribe) gameUnsubscribe();
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
            gameUnsubscribe = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) { showMessage("ルームが削除されました。"); resetLobby(); return; }
                const gameData = doc.data(); localGameState = gameData; 
                if (gameData.status === 'waiting') {
                    if (!screens.lobby.classList.contains('active')) showScreen('lobby');
                    updateLobbyUI(gameData);
                } else if (gameData.status === 'playing' || gameData.status === 'finished') {
                    if (!screens.game.classList.contains('active')) showScreen('game');
                    GameManager.renderGame(gameData);
                }
            });
        }
        
        function updateLobbyUI(gameData) {
            allDomElements.shareCodeDisplay.textContent = currentGameId; allDomElements.playerList.innerHTML = '';
            gameData.players.forEach(player => {
                const playerEl = document.createElement('div');
                playerEl.className = 'flex items-center justify-between p-3 bg-gray-100 rounded-lg';
                playerEl.innerHTML = `<span class="font-medium text-gray-700">${player.name} ${player.id === userId ? '(あなた)' : ''}</span><span class="text-sm font-semibold text-indigo-600">${player.isHost ? 'ホスト' : ''}</span>`;
                allDomElements.playerList.appendChild(playerEl);
            });
            const isHost = gameData.hostId === userId;
            allDomElements.startGameBtn.style.display = isHost ? 'block' : 'none';
            if(isHost) {
                const min = MIN_PLAYERS[gameData.gameType]; const max = MAX_PLAYERS[gameData.gameType]; const playerCount = gameData.players.length;
                allDomElements.startGameBtn.disabled = !(playerCount >= min && playerCount <= max);
                if (playerCount < min) allDomElements.startGameBtn.textContent = `あと${min - playerCount}人必要です`;
                else if (playerCount > max) allDomElements.startGameBtn.textContent = `${max}人以下にしてください`;
                else allDomElements.startGameBtn.textContent = 'ゲーム開始';
            }
        }
        
        async function copyShareCode() {
            const code = allDomElements.shareCodeDisplay.textContent;
            try { await navigator.clipboard.writeText(code); showMessage(`コード "${code}" をコピーしました。`); }
            catch (err) { console.error('Copy failed', err); showMessage("コピーに失敗しました。"); }
        }

        async function startGame() {
            if (localGameState.hostId !== userId) return;
            const newGameState = GameManager.initializeGame(localGameState);
            if(newGameState) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
                await updateDoc(gameRef, { status: 'playing', gameState: newGameState });
            }
        }

        // ========================================================================
        // --- ゲームロジック ---
        // ========================================================================
        const CardUtils = {
            createDeck: (useJokers = 0) => {
                const deck = SUITS.flatMap(s => RANKS.map(r => `${s}_${r}`));
                for (let i = 0; i < useJokers; i++) deck.push(`JOKER_${i}`); return deck;
            },
            shuffle: (a) => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; },
            deal: (deck, numPlayers) => { const h = Array.from({ length: numPlayers }, () => []); deck.forEach((c, i) => h[i % numPlayers].push(c)); return h; },
            createCardElement: (cardString, faceUp = true) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card'; cardEl.dataset.card = cardString;
                if (!faceUp) { cardEl.classList.add('back'); return cardEl; }
                if (cardString.startsWith('JOKER')) { cardEl.innerHTML = `<span class="suit">🃏</span>`; return cardEl; }
                const [suitChar, rank] = cardString.split('_');
                const suitMap = { S: '♠', H: '♥', D: '♦', C: '♣' }; const colorMap = { S: 'black', H: 'red', D: 'red', C: 'black' };
                const rankDisplay = RANK_DISPLAY_MAP[rank] || rank;
                cardEl.classList.add(colorMap[suitChar]);
                cardEl.innerHTML = `<div class="rank">${rankDisplay}</div><div class="suit">${suitMap[suitChar]}</div><div class="suit-sm">${suitMap[suitChar]}</div>`; return cardEl;
            }
        };

        const GameManager = {
            initializeGame: (gameData) => { const logic = gameLogics[gameData.gameType]; return logic?.initialize ? logic.initialize(gameData) : null; },
            renderGame: (gameData) => { allDomElements.gameTitle.textContent = GAME_NAMES[gameData.gameType]; const logic = gameLogics[gameData.gameType]; logic?.render?.(gameData); },
            handleAction: async (action) => {
                if (!currentGameId) return;
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
                try {
                     const logic = gameLogics[localGameState.gameType];
                    // ホバーアクションはトランザクション外で軽量に処理
                    if (action.type === 'HOVER_CARD' || action.type === 'UNHOVER_CARD') {
                        if (logic?.update) {
                            const updatedData = logic.update(localGameState, action, userId);
                            if (updatedData) await updateDoc(gameRef, updatedData);
                        }
                        return;
                    }
                    await runTransaction(db, async (transaction) => {
                        const gameDoc = await transaction.get(gameRef);
                        if (!gameDoc.exists()) throw new Error("Game not found");
                        let currentData = gameDoc.data();
                        if (logic?.update) {
                            const updatedData = logic.update(currentData, action, userId);
                            if (updatedData) transaction.update(gameRef, updatedData);
                        }
                    });
                } catch (error) { console.error("Action failed:", error); showMessage("操作に失敗しました: " + error.message); }
            },
            renderCommonLayout: (gameData, cardSortFn) => {
                const { opponentsArea, myHandAreaCards } = allDomElements;
                opponentsArea.innerHTML = ''; myHandAreaCards.innerHTML = '';
                const myPlayerIndex = gameData.players.findIndex(p => p.id === userId);
                if (myPlayerIndex === -1) return;
                gameData.players.forEach(player => {
                    if (player.id === userId) {
                        const myHand = gameData.gameState.hands?.[player.id] || [];
                        const sortedHand = cardSortFn ? cardSortFn(myHand, gameData.gameState) : myHand;
                        sortedHand.forEach(card => myHandAreaCards.appendChild(CardUtils.createCardElement(card)));
                    } else {
                        const opponentHand = gameData.gameState.hands?.[player.id] || [];
                        const opponentEl = document.createElement('div');
                        opponentEl.dataset.playerId = player.id;
                        const isTurn = gameData.gameState.turn === player.id || gameData.gameState.subTurn?.player === player.id;
                        opponentEl.className = `text-center p-2 rounded-lg ${isTurn ? 'bg-yellow-500 bg-opacity-30' : 'bg-black bg-opacity-20'}`;
                        const winnerRank = gameData.gameState.winners?.find(w => w.id === player.id)?.rank;
                        const rankText = winnerRank ? (winnerRank === 1 ? '👑 勝ち' : (winnerRank > 90 ? '❌' : `${winnerRank}位`)) : '';
                        const score = gameData.gameState.scores?.[player.id];
                        const scoreText = score !== undefined ? `<span class="text-xs">スコア: ${score}</span>` : '';

                        opponentEl.innerHTML = `
                            <p class="font-bold text-sm">${player.name} ${rankText}</p>
                            ${scoreText}
                            <div class="opponent-card-container mt-1">
                                ${opponentHand?.length > 0 ? `<div class="card back text-white text-2xl font-bold">${opponentHand.length}</div>` : ''}
                            </div>
                            <p class="text-xs mt-1 h-4">${gameData.gameState.passedPlayers?.includes(player.id) ? 'パス' : ''}</p>`;
                        opponentsArea.appendChild(opponentEl);
                    }
                });
            }
        };
        
        // --- 各ゲームのロジック ---
        const gameLogics = {
            daifugo: null,
            babanuki: null,
            shinkeisuijaku: null,
            doubt: null,
        };
        
        // ================== 大富豪ロジック ==================
        const daifugoLogic = { /* ... 省略 ... */ };
        gameLogics.daifugo = daifugoLogic;

        // ================== ばば抜きロジック ==================
        const babanukiLogic = { /* ... 省略 ... */ };
        gameLogics.babanuki = babanukiLogic;

        // ================== 神経衰弱ロジック ==================
        const shinkeisuijakuLogic = { /* ... 省略 ... */ };
        gameLogics.shinkeisuijaku = shinkeisuijakuLogic;
        
        // ================== ダウトロジック ==================
        const doubtLogic = {
            initialize: (gameData) => {
                const deck = CardUtils.shuffle(CardUtils.createDeck(0));
                const hands = CardUtils.deal(deck, gameData.players.length);
                const playerHands = {};
                let startingPlayer = null;
                gameData.players.forEach((p, i) => { 
                    playerHands[p.id] = hands[i]; 
                    if(hands[i].includes('S_1')) startingPlayer = p.id;
                });
                return {
                    hands: playerHands,
                    turn: startingPlayer || gameData.players[0].id,
                    field: [],
                    expectedRank: 1,
                    lastPlay: null, // {playerId, claimedRank, count}
                    winners: [],
                    log: "ダウトスタート！"
                };
            },
            sortHand: (hand) => hand.sort((a,b) => parseInt(a.split('_')[1]) - parseInt(b.split('_')[1])),
            render: (gameData) => {
                GameManager.renderCommonLayout(gameData, doubtLogic.sortHand);
                const { tableArea, gameActionsArea, gameStatusMessage, myHandAreaCards } = allDomElements;
                const state = gameData.gameState;
                
                tableArea.innerHTML = '';
                if(state.field.length > 0) {
                    const pile = document.createElement('div');
                    pile.className = 'relative';
                    pile.appendChild(CardUtils.createCardElement('', false));
                    pile.innerHTML += `<div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-2xl font-bold text-white">${state.field.length}</div>`;
                    tableArea.appendChild(pile);
                } else {
                    tableArea.innerHTML = '<p class="text-gray-300">場にカードはありません</p>';
                }
                
                myHandAreaCards.querySelectorAll('.card').forEach(c => c.onclick = () => c.classList.toggle('selected'));
                gameActionsArea.innerHTML = '';
                
                const myRank = state.winners.find(w => w.id === userId)?.rank;
                if(myRank === 1) {
                    gameActionsArea.innerHTML = '<p class="text-lg font-bold text-yellow-300">あなたの勝ちです！</p>';
                } else if (state.turn === userId) {
                    gameActionsArea.innerHTML = '<button id="play-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">出す</button>';
                    if (state.lastPlay) {
                        gameActionsArea.innerHTML += '<button id="doubt-btn" class="ml-4 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">ダウト！</button>';
                    }
                    document.getElementById('play-btn')?.addEventListener('click', () => {
                        const selected = Array.from(myHandAreaCards.querySelectorAll('.card.selected')).map(c => c.dataset.card);
                        if (selected.length > 0) GameManager.handleAction({ type: 'PLAY_CARDS', cards: selected });
                        else showMessage('出すカードを1枚以上選択してください。');
                    });
                    document.getElementById('doubt-btn')?.addEventListener('click', () => GameManager.handleAction({ type: 'CALL_DOUBT' }));
                }

                let status = state.log;
                if(gameData.status !== 'finished') {
                    if (state.turn === userId) {
                         const rankDisplay = RANK_DISPLAY_MAP[state.expectedRank] || state.expectedRank;
                         status = `あなたのターンです。「${rankDisplay}」を出してください。`;
                    } else {
                        status = `${gameData.players.find(p=>p.id === state.turn)?.name ?? ''}さんのターンです。`;
                    }
                }
                gameStatusMessage.textContent = status;
            },
            update: (gameData, action, playerId) => {
                let state = gameData.gameState;
                if (state.winners.some(w => w.id === playerId)) return gameData;

                switch (action.type) {
                    case 'PLAY_CARDS': {
                        if (state.turn !== playerId) return gameData;
                        state.hands[playerId] = state.hands[playerId].filter(c => !action.cards.includes(c));
                        const playData = { cards: action.cards, playerId: playerId, claimedRank: state.expectedRank, count: action.cards.length };
                        state.field.push(playData);
                        state.lastPlay = playData;
                        const rankDisplay = RANK_DISPLAY_MAP[state.expectedRank] || state.expectedRank;
                        state.log = `${userDisplayName}が「${rankDisplay}」を${action.cards.length}枚出しました。`;
                        if (state.hands[playerId].length === 0) {
                            state.winners.push({ id: playerId, rank: 1 });
                            gameData.status = 'finished';
                            state.log = `${userDisplayName}があがりました！`;
                            return gameData;
                        }
                        doubtLogic.setNextTurn(gameData);
                        break;
                    }
                    case 'CALL_DOUBT': {
                        if (state.turn !== playerId || !state.lastPlay) return gameData;
                        const lastPlay = state.lastPlay;
                        const lastPlayerId = lastPlay.playerId;
                        const isLie = lastPlay.cards.some(c => parseInt(c.split('_')[1]) !== lastPlay.claimedRank);
                        const allFieldCards = state.field.flatMap(p => p.cards);
                        
                        let penaltyPlayerId, logMsg;
                        if (isLie) { // ダウト成功
                            penaltyPlayerId = lastPlayerId;
                            logMsg = `${userDisplayName}のダウト成功！ ${gameData.players.find(p=>p.id===lastPlayerId).name}が場のカードを全て引き取ります。`;
                        } else { // ダウト失敗
                            penaltyPlayerId = playerId;
                            logMsg = `${userDisplayName}のダウト失敗！場のカードを全て引き取ります。`;
                        }
                        
                        state.hands[penaltyPlayerId].push(...allFieldCards);
                        state.field = [];
                        state.lastPlay = null;
                        state.log = logMsg;
                        
                        if (isLie) { // 成功時はダウトした人から
                            state.turn = playerId;
                        } else { // 失敗時はダウトした人の次から
                           doubtLogic.setNextTurn(gameData);
                        }
                        break;
                    }
                }
                return gameData;
            },
            setNextTurn: (gameData) => {
                const state = gameData.gameState;
                const currentPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
                let nextPlayerIndex = (currentPlayerIndex + 1) % gameData.players.length;
                while (state.winners.some(w => w.id === gameData.players[nextPlayerIndex].id)) {
                    nextPlayerIndex = (nextPlayerIndex + 1) % gameData.players.length;
                }
                state.turn = gameData.players[nextPlayerIndex].id;
                state.expectedRank = (state.expectedRank % 13) + 1;
            },
            handleLeave: (gameData, playerId) => {
                if(gameData.gameState.turn === playerId) {
                    doubtLogic.setNextTurn(gameData);
                }
                return gameData;
            }
        };

        gameLogics.babanuki = {
            initialize: (gameData) => {
                const deck = CardUtils.shuffle(CardUtils.createDeck(1));
                const hands = CardUtils.deal(deck, gameData.players.length);
                const playerHands = {};
                gameData.players.forEach((p, i) => { playerHands[p.id] = babanukiLogic.removeInitialPairs(hands[i]); });
                const startingPlayer = gameData.players[Math.floor(Math.random() * gameData.players.length)].id;
                return { hands: playerHands, turn: startingPlayer, winners: [], hoverState: null, log: "ばば抜きスタート！" };
            },
            removeInitialPairs: (hand) => {
                const rankMap = new Map();
                hand.forEach(card => {
                    const rank = card.startsWith('JOKER') ? 'JOKER' : card.split('_')[1];
                    if (!rankMap.has(rank)) rankMap.set(rank, []);
                    rankMap.get(rank).push(card);
                });
                const finalHand = [];
                for (const cards of rankMap.values()) {
                    if (cards.length % 2 !== 0) finalHand.push(cards[0]);
                }
                return finalHand;
            },
            render: (gameData) => {
                GameManager.renderCommonLayout(gameData, (hand) => CardUtils.shuffle([...hand]));
                const { opponentsArea, myHandAreaCards, gameActionsArea, gameStatusMessage, tableArea } = allDomElements;
                tableArea.innerHTML = '';
                const state = gameData.gameState;
                const myRank = state.winners.find(w => w.id === userId)?.rank;
                let status = '';
                const activePlayers = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
                const turnPlayerIdxInActive = activePlayers.findIndex(p => p.id === state.turn);
                const targetPlayerOfTurn = activePlayers[(turnPlayerIdxInActive + activePlayers.length - 1) % activePlayers.length];

                if (gameData.status === 'finished') {
                    status = 'ゲーム終了！';
                    if (myRank > gameData.players.length) gameActionsArea.innerHTML = `<p class="text-lg font-bold text-red-400">あなたの負けです！</p>`;
                    else gameActionsArea.innerHTML = `<p class="text-lg font-bold text-yellow-300">あなたは ${myRank} 位です！</p>`;
                } else if (myRank) {
                    status = '勝ち抜け！他のプレイヤーを待っています...';
                    gameActionsArea.innerHTML = `<p class="text-lg font-bold text-yellow-300">あなたは ${myRank} 位です！</p>`;
                } else if (state.turn === userId) {
                    const targetPlayer = targetPlayerOfTurn;
                    status = `${targetPlayer.name}さんからカードを1枚引いてください。`;
                    const targetPlayerElement = opponentsArea.querySelector(`[data-player-id="${targetPlayer.id}"]`);
                    if (targetPlayerElement) {
                        const cardContainer = targetPlayerElement.querySelector('.opponent-card-container');
                        cardContainer.innerHTML = '';
                        cardContainer.classList.add('interactive');
                        const targetHandSize = state.hands[targetPlayer.id]?.length || 0;
                        for (let i = 0; i < targetHandSize; i++) {
                            const cardEl = CardUtils.createCardElement('', false);
                            cardEl.style.cursor = 'pointer';
                            cardEl.addEventListener('click', () => GameManager.handleAction({ type: 'DRAW_CARD', targetPlayerId: targetPlayer.id, cardIndex: i }));
                            cardEl.addEventListener('mouseover', () => GameManager.handleAction({ type: 'HOVER_CARD', targetPlayerId: targetPlayer.id, cardIndex: i }));
                            cardEl.addEventListener('mouseout', () => GameManager.handleAction({ type: 'UNHOVER_CARD' }));
                            cardContainer.appendChild(cardEl);
                        }
                    }
                } else {
                    status = `${gameData.players.find(p => p.id === state.turn)?.name ?? ''}さんのターンです。`;
                    if (targetPlayerOfTurn?.id === userId && state.hoverState) {
                         const cardElements = myHandAreaCards.querySelectorAll('.card');
                         if(cardElements[state.hoverState.cardIndex]) {
                            cardElements[state.hoverState.cardIndex].classList.add('hovered');
                         }
                    }
                }
                gameStatusMessage.textContent = status;
            },
            update: (gameData, action, playerId) => {
                let state = gameData.gameState;
                if (action.type === 'HOVER_CARD' && state.turn === playerId) {
                    gameData.gameState.hoverState = { targetPlayerId: action.targetPlayerId, cardIndex: action.cardIndex };
                    return gameData;
                }
                if (action.type === 'UNHOVER_CARD' && state.turn === playerId) {
                    gameData.gameState.hoverState = null;
                    return gameData;
                }
                if (state.turn !== playerId || state.winners.some(w => w.id === playerId)) return gameData;
                if (action.type === 'DRAW_CARD') {
                    state.hoverState = null;
                    const targetHand = state.hands[action.targetPlayerId];
                    if (!targetHand || targetHand.length === 0) return gameData;
                    const drawnCardIndex = Math.floor(Math.random() * targetHand.length);
                    const drawnCard = targetHand.splice(drawnCardIndex, 1)[0];
                    const drawnRank = drawnCard.startsWith('JOKER') ? 'JOKER' : drawnCard.split('_')[1];
                    const myHand = state.hands[playerId];
                    const matchIndex = myHand.findIndex(card => (card.startsWith('JOKER') ? 'JOKER' : card.split('_')[1]) === drawnRank);
                    if (matchIndex > -1) {
                        myHand.splice(matchIndex, 1);
                    } else {
                        myHand.push(drawnCard);
                    }
                    if (state.hands[action.targetPlayerId].length === 0) {
                        state.winners.push({ id: action.targetPlayerId, rank: state.winners.length + 1 });
                    }
                    if (myHand.length === 0) {
                        state.winners.push({ id: playerId, rank: state.winners.length + 1 });
                    }
                    babanukiLogic.setNextTurn(gameData);
                }
                return gameData;
            },
            setNextTurn: (gameData) => {
                const state = gameData.gameState;
                const activePlayers = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
                if (activePlayers.length <= 1) {
                    if (activePlayers.length === 1) state.winners.push({ id: activePlayers[0].id, rank: gameData.players.length + 1 });
                    gameData.status = 'finished';
                    state.turn = null;
                    return;
                }
                const currentTurnPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
                let nextPlayerIndex = (currentTurnPlayerIndex + 1) % gameData.players.length;
                while (state.winners.some(w => w.id === gameData.players[nextPlayerIndex].id)) {
                    nextPlayerIndex = (nextPlayerIndex + 1) % gameData.players.length;
                }
                state.turn = gameData.players[nextPlayerIndex].id;
            },
            handleLeave: (gameData, playerId) => {
                const state = gameData.gameState;
                if (!state.winners.some(w => w.id === playerId)) {
                    state.winners.push({ id: playerId, rank: 99, left: true });
                }
                if (state.turn === playerId) {
                    babanukiLogic.setNextTurn(gameData);
                }
                return gameData;
            }
        };
        
        gameLogics.shinkeisuijaku = {
            initialize: (gameData) => {
                const deck = CardUtils.shuffle(CardUtils.createDeck(0));
                const boardCards = deck.map(card => ({ cardString: card, isFaceUp: false, isMatched: false }));
                const scores = gameData.players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                return { boardCards, scores, turn: gameData.players[0].id, flippedIndices: [], winners: [] };
            },
            render: (gameData) => {
                GameManager.renderCommonLayout(gameData);
                const { tableArea, gameActionsArea, gameStatusMessage, myHandAreaCards } = allDomElements;
                myHandAreaCards.innerHTML = `<p class="text-center w-full">あなたのスコア: ${gameData.gameState.scores[userId] ?? 0}</p>`;
                tableArea.innerHTML = '';
                tableArea.className = 'flex-grow flex flex-col items-center justify-center bg-green-700 rounded-lg p-2 shadow-inner mb-2 relative min-h-[140px] grid-layout';
                const state = gameData.gameState;
                state.boardCards.forEach((card, index) => {
                    const cardEl = CardUtils.createCardElement(card.cardString, card.isFaceUp);
                    if (card.isMatched) { cardEl.classList.add('matched'); }
                    else if (!card.isFaceUp && state.turn === userId && state.flippedIndices.length < 2) {
                        cardEl.addEventListener('click', () => GameManager.handleAction({ type: 'FLIP_CARD', index }));
                    }
                    tableArea.appendChild(cardEl);
                });
                let status = '';
                if (gameData.status === 'finished') {
                    let winnerText = 'ゲーム終了！';
                    const maxScore = Math.max(...Object.values(state.scores));
                    const winners = gameData.players.filter(p => state.scores[p.id] === maxScore);
                    if (winners.length > 1) { winnerText += `勝者: ${winners.map(w => w.name).join(', ')} (引き分け)`; }
                    else if (winners.length === 1) { winnerText += `勝者: ${winners[0].name}`; }
                    status = winnerText;
                } else if (state.turn === userId) {
                    status = `あなたのターンです。カードを${2 - state.flippedIndices.length}枚めくってください。`;
                } else {
                    status = `${gameData.players.find(p => p.id === state.turn)?.name ?? ''}さんのターンです。`;
                }
                gameStatusMessage.textContent = status;
                if (state.flippedIndices.length === 2 && state.turn === userId) {
                    const card1 = state.boardCards[state.flippedIndices[0]];
                    const card2 = state.boardCards[state.flippedIndices[1]];
                    const rank1 = card1.cardString.split('_')[1];
                    const rank2 = card2.cardString.split('_')[1];
                    if (rank1 !== rank2) {
                        clearTimeout(clientSideTimer);
                        clientSideTimer = setTimeout(() => { GameManager.handleAction({ type: 'CHECK_PAIR' }); }, 1000);
                    }
                }
            },
            update: (gameData, action, playerId) => {
                let state = gameData.gameState;
                if (state.turn !== playerId) return gameData;
                if (action.type === 'FLIP_CARD') {
                    if (state.flippedIndices.length >= 2 || state.boardCards[action.index].isFaceUp) { return gameData; }
                    state.boardCards[action.index].isFaceUp = true;
                    state.flippedIndices.push(action.index);
                    if (state.flippedIndices.length === 2) {
                        const card1 = state.boardCards[state.flippedIndices[0]];
                        const card2 = state.boardCards[state.flippedIndices[1]];
                        const rank1 = card1.cardString.split('_')[1];
                        const rank2 = card2.cardString.split('_')[1];
                        if (rank1 === rank2) {
                            card1.isMatched = true; card2.isMatched = true; state.scores[playerId]++; state.flippedIndices = [];
                            if (state.boardCards.every(c => c.isMatched)) { gameData.status = 'finished'; }
                        }
                    }
                } else if (action.type === 'CHECK_PAIR') {
                    state.boardCards[state.flippedIndices[0]].isFaceUp = false; state.boardCards[state.flippedIndices[1]].isFaceUp = false;
                    state.flippedIndices = [];
                    shinkeisuijakuLogic.setNextTurn(gameData);
                }
                return gameData;
            },
            setNextTurn: (gameData) => {
                const state = gameData.gameState;
                const currentPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
                state.turn = gameData.players[(currentPlayerIndex + 1) % gameData.players.length].id;
            },
             handleLeave: (gameData, playerId) => {
                if(gameData.gameState.turn === playerId) { shinkeisuijakuLogic.setNextTurn(gameData); }
                return gameData;
            }
        };

        gameLogics.doubt = doubtLogic;

        // すべてのゲームロジックを割り当て
        for (const key in gameLogics) {
            if (gameLogics[key] === null) {
                const logic = window[key + 'Logic'];
                if(logic) gameLogics[key] = logic;
            }
        }


        window.onload = initialize;
    </script>
</body>
</html>

