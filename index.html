<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>マルチプレイトランプゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            overscroll-behavior: none; /* スワイプでのページの戻る/進むを無効化 */
            touch-action: manipulation; /* ダブルタップズームを無効化 */
        }
        .screen { display: none; }
        .screen.active { display: flex; flex-direction: column; }
        
        /* カードのスタイル */
        .card {
            width: 70px;
            height: 98px;
            border-radius: 6px;
            background-color: white;
            border: 1px solid #B0B0B0;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            position: relative;
            user-select: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 4px 8px 10px rgba(0,0,0,0.2); }
        .card.red { color: #D92D20; }
        .card.black { color: #101828; }
        .card .rank { position: absolute; top: 4px; left: 6px; font-size: 14px; }
        .card .suit { font-size: 28px; }
        .card .suit-sm { position: absolute; bottom: 4px; right: 6px; font-size: 14px; transform: rotate(180deg); }
        .card.back {
            background-image:
                linear-gradient(45deg, #4477ff 25%, transparent 25%),
                linear-gradient(-45deg, #4477ff 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #4477ff 75%),
                linear-gradient(-45deg, transparent 75%, #4477ff 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #3366ee;
        }
        .card.selected, .card.hovered { transform: translateY(-15px); border: 2px solid #3b82f6; }
        .card.disabled { opacity: 0.5; cursor: not-allowed; }
        .card.matched { visibility: hidden; }
        
        /* 手札のレイアウト */
        #my-hand-area-cards {
            display: flex;
            flex-wrap: nowrap; /* スマホで手札が折り返さないように */
            overflow-x: auto; /* 横スクロールを可能に */
            justify-content: flex-start; /* 左詰め */
            align-items: center;
            padding: 10px;
            -webkit-overflow-scrolling: touch; /* iOSでの慣性スクロール */
        }
        #my-hand-area-cards .card {
            flex-shrink: 0; /* カードが縮まないように */
            margin-left: -30px;
        }
        #my-hand-area-cards .card:first-child { margin-left: 0; }

        .opponent-card-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .opponent-card-container.interactive .card {
            margin: 0 -15px 0 0 !important;
        }
        
        #table-area.grid-layout {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(65px, 1fr));
            gap: 8px;
            padding: 8px;
            width: 100%;
            height: 100%;
            overflow-y: auto;
        }
        #table-area.grid-layout .card {
            width: 100%;
            height: 80px; /* Adjust height for grid */
        }
    </style>
</head>
<body class="bg-gray-100 antialiased">

    <div id="app-container" class="max-w-md mx-auto min-h-screen bg-white shadow-lg">

        <!-- ===== ホーム画面 ===== -->
        <div id="home-screen" class="screen active p-6">
            <header class="text-center mb-8">
                <h1 class="text-3xl font-bold text-gray-800">トランプゲーム</h1>
                <p class="text-gray-500 mt-2">遊びたいゲームを選んでください</p>
            </header>
            <div class="space-y-4">
                <button data-game="daifugo" class="game-select-btn w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">大富豪</button>
                <button data-game="babanuki" class="game-select-btn w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">ばば抜き</button>
                <button data-game="shinkeisuijaku" class="game-select-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">神経衰弱</button>
                <button data-game="doubt" class="game-select-btn w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">ダウト</button>
            </div>
             <div class="mt-8 text-center space-y-4">
                <div>
                    <label for="display-name-input" class="text-sm text-gray-600">あなたの名前</label>
                    <div class="flex items-center space-x-2 mt-1">
                        <input type="text" id="display-name-input" class="flex-grow w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="名前を入力...">
                        <button id="save-name-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">保存</button>
                    </div>
                </div>
                <div>
                    <p class="text-sm text-gray-400">あなたのID:</p>
                    <p id="user-id-display" class="text-xs text-gray-500 bg-gray-100 p-2 rounded break-all"></p>
                </div>
            </div>
        </div>

        <!-- ===== ロビー画面 ===== -->
        <div id="lobby-screen" class="screen p-6">
            <header class="text-center mb-6 relative">
                <h1 id="lobby-title" class="text-2xl font-bold text-gray-800"></h1>
                <button id="back-to-home-btn" class="absolute top-0 left-0 text-gray-500 hover:text-gray-800 p-2">&larr; 戻る</button>
                <p class="text-gray-500 mt-1">友達とコードを共有して参加者を集めよう</p>
            </header>
            <div id="join-create-section">
                <div class="space-y-4">
                     <button id="create-game-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">新しいルームを作成</button>
                    <div class="relative flex items-center justify-center text-gray-400"><span class="px-2 bg-white">または</span></div>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="join-code-input" placeholder="共有コードを入力" class="flex-grow w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <button id="join-game-btn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-3 px-4 rounded-lg shadow-md">参加</button>
                    </div>
                </div>
                <!-- 大富豪ローカルルール設定 -->
                <div id="daifugo-rules-section" class="hidden mt-6 p-4 border rounded-lg bg-gray-50">
                    <h3 class="font-bold mb-3 text-gray-800 flex justify-between items-center">
                        <span>大富豪ローカルルール設定</span>
                        <button id="rule-info-btn" class="text-sm text-blue-500 hover:underline">ルール説明</button>
                    </h3>
                    <div id="daifugo-rules-list" class="space-y-2 text-sm text-gray-700 grid grid-cols-2 gap-x-4 gap-y-2">
                        <!-- ルールチェックボックスがJSでここに追加されます -->
                    </div>
                </div>
            </div>
            <div id="waiting-room-section" class="hidden">
                <div class="text-center mb-6">
                    <p class="text-gray-600">共有コード</p>
                    <div class="bg-gray-100 p-4 rounded-lg mt-2 flex items-center justify-center">
                        <p id="share-code-display" class="text-3xl font-bold tracking-widest text-gray-800"></p>
                        <button id="copy-code-btn" class="ml-4 p-2 rounded-lg bg-gray-200 hover:bg-gray-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                    </div>
                </div>
                <div class="mb-6"><h2 class="text-xl font-bold text-gray-700 mb-3">参加者</h2><div id="player-list" class="space-y-2"></div></div>
                <div class="mt-8 space-y-4">
                     <button id="start-game-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">ゲーム開始</button>
                    <button id="leave-game-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg shadow-md">ルームを抜ける</button>
                </div>
            </div>
        </div>

        <!-- ===== ゲーム画面 ===== -->
        <div id="game-screen" class="screen p-2 md:p-4 bg-green-800 min-h-screen text-white">
            <div id="game-header" class="flex justify-between items-center mb-2 p-2 bg-black bg-opacity-20 rounded-lg">
                <h2 id="game-title" class="text-xl font-bold"></h2>
                <button id="leave-game-ingame-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg text-sm">ルーム退出</button>
            </div>
            <div id="opponents-area" class="flex justify-around items-start flex-wrap gap-2 mb-2 min-h-[100px]"></div>
            <div id="table-area" class="flex-grow flex flex-col items-center justify-center bg-green-700 rounded-lg p-2 shadow-inner mb-2 relative min-h-[140px]"></div>
            <div id="my-info-area" class="flex flex-col items-center justify-center">
                <div id="my-hand-area-cards" class="w-full min-h-[120px]"></div>
                <div id="game-actions-area" class="mt-2 h-10"></div>
            </div>
            <div id="game-status-message" class="text-center font-semibold p-2 bg-black bg-opacity-30 rounded-lg mt-2"></div>
        </div>

        <!-- ===== メッセージ表示用モーダル ===== -->
        <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-sm w-11/12 text-center">
                <p id="message-text" class="text-lg text-gray-800"></p>
                <button id="close-message-btn" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">OK</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, arrayUnion, arrayRemove, writeBatch, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- 定数と設定 ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyDrgRoyNxnXHia1ASG1dup-hm2p4D0IpGw",
            authDomain: "card-game-platform-f967a.firebaseapp.com",
            projectId: "card-game-platform-f967a",
            storageBucket: "card-game-platform-f967a.firebasestorage.app",
            messagingSenderId: "165676867683",
            appId: "1:165676867683:web:dfd9677b260edf12161856",
            measurementId: "G-HK9L7PR991"
        };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-card-game-app';
        const GAME_NAMES = { daifugo: "大富豪", babanuki: "ばば抜き", shinkeisuijaku: "神経衰弱", doubt: "ダウト" };
        const MIN_PLAYERS = { daifugo: 2, babanuki: 2, shinkeisuijaku: 2, doubt: 2 };
        const MAX_PLAYERS = { daifugo: 6, babanuki: 8, shinkeisuijaku: 6, doubt: 8 };
        const SUITS = ['H', 'D', 'C', 'S'];
        const RANKS = Array.from({ length: 13 }, (_, i) => i + 1); // 1(A) to 13(K)
        const RANK_DISPLAY_MAP = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K' };
        const DAIFUGO_RULES = {
            eightCut: { label: "8切り", default: true, description: "8を出すと場が流れます。" },
            elevenBack: { label: "11バック", default: true, description: "J(11)を出すとカードの強さが一時的に逆転します。" },
            shibari: { label: "しばり", default: true, description: "前の人と同じスートのカードが続くと、以降そのスートしか出せなくなります。" },
            revolution: { label: "革命", default: true, description: "同じ数字4枚以上でカードの強さが永続的に逆転します。" },
            sevenPass: { label: "7渡し", default: false, description: "出した7の枚数分、次の人に手札を渡せます。" },
            tenDiscard: { label: "10捨て", default: false, description: "出した10の枚数分、手札を捨てられます。" },
        };

        // --- グローバル変数 ---
        let app, auth, db;
        let userId, userDisplayName;
        let currentGameId = null;
        let selectedGameType = null;
        let gameUnsubscribe = null;
        let localGameState = {};
        let clientSideTimer = null;

        // --- DOM要素 ---
        const screens = { home: document.getElementById('home-screen'), lobby: document.getElementById('lobby-screen'), game: document.getElementById('game-screen') };
        const allDomElements = {
            userIdDisplay: document.getElementById('user-id-display'),
            lobbyTitle: document.getElementById('lobby-title'),
            createGameBtn: document.getElementById('create-game-btn'),
            joinCodeInput: document.getElementById('join-code-input'),
            joinGameBtn: document.getElementById('join-game-btn'),
            joinCreateSection: document.getElementById('join-create-section'),
            waitingRoomSection: document.getElementById('waiting-room-section'),
            shareCodeDisplay: document.getElementById('share-code-display'),
            playerList: document.getElementById('player-list'),
            startGameBtn: document.getElementById('start-game-btn'),
            leaveGameBtn: document.getElementById('leave-game-btn'),
            copyCodeBtn: document.getElementById('copy-code-btn'),
            messageModal: document.getElementById('message-modal'),
            messageText: document.getElementById('message-text'),
            closeMessageBtn: document.getElementById('close-message-btn'),
            backToHomeBtn: document.getElementById('back-to-home-btn'),
            daifugoRulesSection: document.getElementById('daifugo-rules-section'),
            daifugoRulesList: document.getElementById('daifugo-rules-list'),
            ruleInfoBtn: document.getElementById('rule-info-btn'),
            gameTitle: document.getElementById('game-title'),
            leaveGameIngameBtn: document.getElementById('leave-game-ingame-btn'),
            opponentsArea: document.getElementById('opponents-area'),
            tableArea: document.getElementById('table-area'),
            myHandAreaCards: document.getElementById('my-hand-area-cards'),
            gameActionsArea: document.getElementById('game-actions-area'),
            gameStatusMessage: document.getElementById('game-status-message'),
            displayNameInput: document.getElementById('display-name-input'),
            saveNameBtn: document.getElementById('save-name-btn'),
        };

        // --- 初期化 & 認証 ---
        async function initialize() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            onAuthStateChanged(auth, user => handleAuthState(user));
            setupEventListeners();
            setupDaifugoRules();
            
            // ローカルストレージから名前を読み込む
            const savedName = localStorage.getItem('cardGamePlayerName');
            if (savedName) {
                userDisplayName = savedName;
                allDomElements.displayNameInput.value = savedName;
            }
        }

        async function handleAuthState(user) {
            if (user) {
                userId = user.uid;
                allDomElements.userIdDisplay.textContent = userId;
                if (!userDisplayName) { // 名前が設定されていなければデフォルト名を生成
                    userDisplayName = `Player-${userId.substring(0, 4)}`;
                    allDomElements.displayNameInput.value = userDisplayName;
                }
            } else {
                try {
                    await (typeof __initial_auth_token !== 'undefined' && __initial_auth_token
                        ? signInWithCustomToken(auth, __initial_auth_token)
                        : signInAnonymously(auth));
                } catch (error) { console.error("Authentication failed:", error); showMessage("認証に失敗しました。"); }
            }
        }

        // --- イベントリスナー設定 ---
        function setupEventListeners() {
            document.querySelectorAll('.game-select-btn').forEach(btn => btn.addEventListener('click', handleGameSelect));
            allDomElements.createGameBtn.addEventListener('click', createGame);
            allDomElements.joinGameBtn.addEventListener('click', joinGame);
            allDomElements.leaveGameBtn.addEventListener('click', leaveGame);
            allDomElements.leaveGameIngameBtn.addEventListener('click', leaveGame);
            allDomElements.startGameBtn.addEventListener('click', startGame);
            allDomElements.copyCodeBtn.addEventListener('click', copyShareCode);
            allDomElements.closeMessageBtn.addEventListener('click', () => allDomElements.messageModal.classList.add('hidden'));
            allDomElements.backToHomeBtn.addEventListener('click', resetLobby);
            allDomElements.ruleInfoBtn.addEventListener('click', showDaifugoRuleInfo);
            allDomElements.saveNameBtn.addEventListener('click', savePlayerName);
            allDomElements.joinCodeInput.addEventListener('input', e => e.target.value = e.target.value.toUpperCase());
        }
        
        // --- 画面遷移 & UIヘルパー ---
        const showScreen = (screenName) => { Object.values(screens).forEach(s => s.classList.remove('active')); screens[screenName].classList.add('active'); };
        const showMessage = (message, isHtml = false) => { 
            if(isHtml) allDomElements.messageText.innerHTML = message;
            else allDomElements.messageText.textContent = message;
            allDomElements.messageModal.classList.remove('hidden'); 
        };
        const generateGameId = () => Array(6).fill(0).map(() => 'ABCDEFGHIJKLMNPQRSTUVWXYZ123456789'[Math.floor(Math.random() * 35)]).join('');

        // --- 名前変更ロジック ---
        async function savePlayerName() {
            const newName = allDomElements.displayNameInput.value.trim();
            if (newName && newName.length > 0 && newName.length <= 10) {
                userDisplayName = newName;
                localStorage.setItem('cardGamePlayerName', newName);
                showMessage('名前を保存しました。');
                
                // もしルームに参加中なら、Firestoreのデータも更新
                if (currentGameId && localGameState.players?.some(p => p.id === userId)) {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
                    try {
                        await runTransaction(db, async (transaction) => {
                            const gameDoc = await transaction.get(gameRef);
                            if (!gameDoc.exists()) return;
                            const gameData = gameDoc.data();
                            const playerIndex = gameData.players.findIndex(p => p.id === userId);
                            if (playerIndex > -1) {
                                gameData.players[playerIndex].name = newName;
                                transaction.update(gameRef, { players: gameData.players });
                            }
                        });
                    } catch (error) {
                        console.error("Error updating name in lobby:", error);
                    }
                }
            } else {
                showMessage('名前は1文字以上10文字以下で入力してください。');
            }
        }

        // --- ホーム画面ロジック ---
        function handleGameSelect(e) {
            if (!auth.currentUser) return showMessage("ユーザー情報が読み込まれていません。");
            selectedGameType = e.currentTarget.dataset.game;
            allDomElements.lobbyTitle.textContent = `${GAME_NAMES[selectedGameType]} のロビー`;
            allDomElements.daifugoRulesSection.classList.toggle('hidden', selectedGameType !== 'daifugo');
            allDomElements.tableArea.classList.remove('grid-layout'); // 前のゲームのレイアウトをリセット
            showScreen('lobby');
        }

        // --- 大富豪ルール設定 ---
        function setupDaifugoRules() {
            const listEl = allDomElements.daifugoRulesList;
            listEl.innerHTML = '';
            for (const ruleKey in DAIFUGO_RULES) {
                const rule = DAIFUGO_RULES[ruleKey];
                const labelEl = document.createElement('label');
                labelEl.className = 'flex items-center space-x-2 cursor-pointer';
                labelEl.innerHTML = `<input type="checkbox" name="${ruleKey}" ${rule.default ? 'checked' : ''} class="rounded text-blue-500 focus:ring-blue-500"><span>${rule.label}</span>`;
                listEl.appendChild(labelEl);
            }
        }
        function getSelectedDaifugoRules() {
            const rules = {};
            document.querySelectorAll('#daifugo-rules-list input[type="checkbox"]').forEach(checkbox => { rules[checkbox.name] = checkbox.checked; });
            return rules;
        }
        function showDaifugoRuleInfo() {
            let infoText = '<ul class="text-left list-disc pl-5 space-y-2">';
            for(const key in DAIFUGO_RULES) { infoText += `<li><strong>${DAIFUGO_RULES[key].label}:</strong> ${DAIFUGO_RULES[key].description}</li>`; }
            infoText += '</ul>';
            showMessage(infoText, true);
        }

        // --- ロビーロジック ---
        async function createGame() {
            const gameId = generateGameId(); currentGameId = gameId;
            const hostPlayer = { id: userId, name: userDisplayName, isHost: true, rank: 'heimin' };
            const gameDoc = { gameType: selectedGameType, hostId: userId, players: [hostPlayer], status: 'waiting', createdAt: new Date() };
            if (selectedGameType === 'daifugo') gameDoc.rules = getSelectedDaifugoRules();
            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
                await setDoc(gameRef, gameDoc);
                listenToGameUpdates(gameId);
                allDomElements.joinCreateSection.classList.add('hidden'); allDomElements.waitingRoomSection.classList.remove('hidden');
            } catch (error) { console.error("Error creating game:", error); showMessage("ゲームの作成に失敗しました。"); }
        }

        async function joinGame() {
            const gameId = allDomElements.joinCodeInput.value.trim();
            if (!gameId) return showMessage("共有コードを入力してください。");
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
            try {
                const gameDoc = await getDoc(gameRef); if (!gameDoc.exists()) return showMessage("ルームが見つかりません。");
                const gameData = gameDoc.data(); if (gameData.status !== 'waiting') return showMessage("このゲームは既に参加できません。");
                if (gameData.players.length >= MAX_PLAYERS[gameData.gameType]) return showMessage("このルームは満員です。");
                if (!gameData.players.some(p => p.id === userId)) {
                    const newPlayer = { id: userId, name: userDisplayName, isHost: false, rank: 'heimin' };
                    await updateDoc(gameRef, { players: arrayUnion(newPlayer) });
                }
                currentGameId = gameId; selectedGameType = gameData.gameType;
                listenToGameUpdates(gameId);
                allDomElements.lobbyTitle.textContent = `${GAME_NAMES[selectedGameType]} のロビー`;
                allDomElements.daifugoRulesSection.classList.toggle('hidden', selectedGameType !== 'daifugo');
                allDomElements.joinCreateSection.classList.add('hidden'); allDomElements.waitingRoomSection.classList.remove('hidden');
            } catch (error) { console.error("Error joining game:", error); showMessage("ゲームへの参加に失敗しました。"); }
        }
        
        async function leaveGame() {
            if (!currentGameId || !userId) return;
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef); if (!gameDoc.exists()) return;
                    let gameData = gameDoc.data();
                    const remainingPlayers = gameData.players.filter(p => p.id !== userId);
                    if (remainingPlayers.length === 0) { transaction.delete(gameRef); }
                    else {
                        if (gameData.hostId === userId) { remainingPlayers[0].isHost = true; gameData.hostId = remainingPlayers[0].id; }
                        gameData.players = remainingPlayers;
                        if(gameData.status === 'playing') {
                           const logic = gameLogics[gameData.gameType];
                           if(logic?.handleLeave) gameData = logic.handleLeave(gameData, userId);
                        }
                        transaction.update(gameRef, gameData);
                    }
                });
            } catch (error) { console.error("Error leaving game:", error); }
            finally { resetLobby(); }
        }
        
        function resetLobby() {
            if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
            currentGameId = null; localGameState = {}; allDomElements.joinCodeInput.value = '';
            allDomElements.waitingRoomSection.classList.add('hidden'); allDomElements.joinCreateSection.classList.remove('hidden');
            showScreen('home');
        }

        function listenToGameUpdates(gameId) {
            if (gameUnsubscribe) gameUnsubscribe();
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
            gameUnsubscribe = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) { showMessage("ルームが削除されました。"); resetLobby(); return; }
                const gameData = doc.data(); localGameState = gameData; 
                if (gameData.status === 'waiting') {
                    if (!screens.lobby.classList.contains('active')) showScreen('lobby');
                    updateLobbyUI(gameData);
                } else if (gameData.status === 'playing' || gameData.status === 'finished') {
                    if (!screens.game.classList.contains('active')) showScreen('game');
                    GameManager.renderGame(gameData);
                }
            });
        }
        
        function updateLobbyUI(gameData) {
            allDomElements.shareCodeDisplay.textContent = currentGameId; allDomElements.playerList.innerHTML = '';
            gameData.players.forEach(player => {
                const playerEl = document.createElement('div');
                playerEl.className = 'flex items-center justify-between p-3 bg-gray-100 rounded-lg';
                playerEl.innerHTML = `<span class="font-medium text-gray-700">${player.name} ${player.id === userId ? '(あなた)' : ''}</span><span class="text-sm font-semibold text-indigo-600">${player.isHost ? 'ホスト' : ''}</span>`;
                allDomElements.playerList.appendChild(playerEl);
            });
            const isHost = gameData.hostId === userId;
            allDomElements.startGameBtn.style.display = isHost ? 'block' : 'none';
            if(isHost) {
                const min = MIN_PLAYERS[gameData.gameType]; const max = MAX_PLAYERS[gameData.gameType]; const playerCount = gameData.players.length;
                allDomElements.startGameBtn.disabled = !(playerCount >= min && playerCount <= max);
                if (playerCount < min) allDomElements.startGameBtn.textContent = `あと${min - playerCount}人必要です`;
                else if (playerCount > max) allDomElements.startGameBtn.textContent = `${max}人以下にしてください`;
                else allDomElements.startGameBtn.textContent = 'ゲーム開始';
            }
        }
        
        async function copyShareCode() {
            const code = allDomElements.shareCodeDisplay.textContent;
            try { await navigator.clipboard.writeText(code); showMessage(`コード "${code}" をコピーしました。`); }
            catch (err) { console.error('Copy failed', err); showMessage("コピーに失敗しました。"); }
        }

        async function startGame() {
            if (localGameState.hostId !== userId) return;
            const newGameState = GameManager.initializeGame(localGameState);
            if(newGameState) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
                await updateDoc(gameRef, { status: 'playing', gameState: newGameState });
            }
        }

        // ========================================================================
        // --- ゲームロジック ---
        // ========================================================================
        const CardUtils = {
            createDeck: (useJokers = 0) => {
                const deck = SUITS.flatMap(s => RANKS.map(r => `${s}_${r}`));
                for (let i = 0; i < useJokers; i++) deck.push(`JOKER_${i}`); return deck;
            },
            shuffle: (a) => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; },
            deal: (deck, numPlayers) => { const h = Array.from({ length: numPlayers }, () => []); deck.forEach((c, i) => h[i % numPlayers].push(c)); return h; },
            createCardElement: (cardString, faceUp = true) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card'; cardEl.dataset.card = cardString;
                if (!faceUp) { cardEl.classList.add('back'); return cardEl; }
                if (cardString.startsWith('JOKER')) { cardEl.innerHTML = `<span class="suit">🃏</span>`; return cardEl; }
                const [suitChar, rank] = cardString.split('_');
                const suitMap = { S: '♠', H: '♥', D: '♦', C: '♣' }; const colorMap = { S: 'black', H: 'red', D: 'red', C: 'black' };
                const rankDisplay = RANK_DISPLAY_MAP[rank] || rank;
                cardEl.classList.add(colorMap[suitChar]);
                cardEl.innerHTML = `<div class="rank">${rankDisplay}</div><div class="suit">${suitMap[suitChar]}</div><div class="suit-sm">${suitMap[suitChar]}</div>`; return cardEl;
            }
        };

        const GameManager = {
            initializeGame: (gameData) => { const logic = gameLogics[gameData.gameType]; return logic?.initialize ? logic.initialize(gameData) : null; },
            renderGame: (gameData) => { allDomElements.gameTitle.textContent = GAME_NAMES[gameData.gameType]; const logic = gameLogics[gameData.gameType]; logic?.render?.(gameData); },
            handleAction: async (action) => {
                if (!currentGameId) return;
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
                try {
                     const logic = gameLogics[localGameState.gameType];
                    // ホバーアクションはトランザクション外で軽量に処理
                    if (action.type === 'HOVER_CARD' || action.type === 'UNHOVER_CARD') {
                        if (logic?.update) {
                            const updatedData = logic.update(localGameState, action, userId);
                            if (updatedData) await updateDoc(gameRef, updatedData);
                        }
                        return;
                    }
                    await runTransaction(db, async (transaction) => {
                        const gameDoc = await transaction.get(gameRef);
                        if (!gameDoc.exists()) throw new Error("Game not found");
                        let currentData = gameDoc.data();
                        if (logic?.update) {
                            const updatedData = logic.update(currentData, action, userId);
                            if (updatedData) transaction.update(gameRef, updatedData);
                        }
                    });
                } catch (error) { console.error("Action failed:", error); showMessage("操作に失敗しました: " + error.message); }
            },
            renderCommonLayout: (gameData, cardSortFn) => {
                const { opponentsArea, myHandAreaCards } = allDomElements;
                opponentsArea.innerHTML = ''; myHandAreaCards.innerHTML = '';
                const myPlayerIndex = gameData.players.findIndex(p => p.id === userId);
                if (myPlayerIndex === -1) return;
                gameData.players.forEach(player => {
                    if (player.id === userId) {
                        const myHand = gameData.gameState.hands?.[player.id] || [];
                        const sortedHand = cardSortFn ? cardSortFn(myHand, gameData.gameState) : myHand;
                        sortedHand.forEach(card => myHandAreaCards.appendChild(CardUtils.createCardElement(card)));
                    } else {
                        const opponentHand = gameData.gameState.hands?.[player.id] || [];
                        const opponentEl = document.createElement('div');
                        opponentEl.dataset.playerId = player.id;
                        const isTurn = gameData.gameState.turn === player.id || gameData.gameState.subTurn?.player === player.id;
                        opponentEl.className = `text-center p-2 rounded-lg ${isTurn ? 'bg-yellow-500 bg-opacity-30' : 'bg-black bg-opacity-20'}`;
                        const winnerRank = gameData.gameState.winners?.find(w => w.id === player.id)?.rank;
                        const rankText = winnerRank ? (winnerRank === 1 ? '👑 勝ち' : (winnerRank > 90 ? '❌' : `${winnerRank}位`)) : '';
                        const score = gameData.gameState.scores?.[player.id];
                        const scoreText = score !== undefined ? `<span class="text-xs">スコア: ${score}</span>` : '';

                        opponentEl.innerHTML = `
                            <p class="font-bold text-sm">${player.name} ${rankText}</p>
                            ${scoreText}
                            <div class="opponent-card-container mt-1">
                                ${opponentHand?.length > 0 ? `<div class="card back text-white text-2xl font-bold">${opponentHand.length}</div>` : ''}
                            </div>
                            <p class="text-xs mt-1 h-4">${gameData.gameState.passedPlayers?.includes(player.id) ? 'パス' : ''}</p>`;
                        opponentsArea.appendChild(opponentEl);
                    }
                });
            }
        };
        
        // --- 各ゲームのロジック ---
        // ================== 大富豪ロジック ==================
        const daifugoLogic = { /* ... 省略 ... */ };

        // ================== ばば抜きロジック ==================
        const babanukiLogic = { /* ... 省略 ... */ };

        // ================== 神経衰弱ロジック ==================
        const shinkeisuijakuLogic = { /* ... 省略 ... */ };
        
        // ================== ダウトロジック ==================
        const doubtLogic = { /* ... 省略 ... */ };

        const gameLogics = {
            daifugo: daifugoLogic,
            babanuki: babanukiLogic,
            shinkeisuijaku: shinkeisuijakuLogic,
            doubt: doubtLogic,
        };
        
        // ================== 大富豪ロジック詳細 ==================
        daifugoLogic.getCardStrength = (card, isReversed = false, isRoundReversed = false) => {
            if (card.startsWith('JOKER')) return isReversed ? 0 : 99;
            const rank = parseInt(card.split('_')[1]);
            let strength = rank; if (rank <= 2) strength += 13;
            const finalReversed = isReversed !== isRoundReversed;
            return finalReversed ? 16 - strength : strength;
        };
        daifugoLogic.sortHand = (hand, gameState) => hand.sort((a, b) => daifugoLogic.getCardStrength(a, gameState.isReversed, gameState.isRoundReversed) - daifugoLogic.getCardStrength(b, gameState.isReversed, gameState.isRoundReversed));
        daifugoLogic.initialize = (gameData) => {
            const deck = CardUtils.shuffle(CardUtils.createDeck(2));
            const hands = CardUtils.deal(deck, gameData.players.length);
            const playerHands = {};
            let startingPlayer = gameData.players[Math.floor(Math.random() * gameData.players.length)].id;
            gameData.players.forEach((p, i) => { playerHands[p.id] = hands[i]; });
            return { hands: playerHands, turn: startingPlayer, field: { cards: [], player: null, suit: null }, passedPlayers: [], winners: [], isReversed: false, isRoundReversed: false, isShibari: false, shibariSuit: null, log: "大富豪スタート！", rules: gameData.rules, subTurn: null };
        };
        daifugoLogic.render = (gameData) => {
            GameManager.renderCommonLayout(gameData, daifugoLogic.sortHand);
            const { tableArea, myHandAreaCards, gameActionsArea, gameStatusMessage } = allDomElements;
            tableArea.innerHTML = '';
            if (gameData.gameState.field.cards.length > 0) {
                const fieldCardsEl = document.createElement('div'); fieldCardsEl.className = 'flex -space-x-8';
                gameData.gameState.field.cards.forEach(c => fieldCardsEl.appendChild(CardUtils.createCardElement(c)));
                const lastName = gameData.players.find(p => p.id === gameData.gameState.field.player)?.name ?? '';
                tableArea.innerHTML = `<p class="text-xs text-center mb-1 text-gray-200">出した人: ${lastName}</p>`;
                tableArea.appendChild(fieldCardsEl);
            } else { tableArea.innerHTML = '<p class="text-gray-300">場は流れています</p>'; }
            const myRank = gameData.gameState.winners.find(w => w.id === userId)?.rank;
            myHandAreaCards.querySelectorAll('.card').forEach(c => { c.onclick = () => c.classList.toggle('selected'); });
            let status = '';
            if (gameData.gameState.isReversed) status += '⚡革命中 ';
            if (gameData.gameState.isShibari) status += `⛓${gameData.gameState.shibariSuit}しばり `;
            if (gameData.gameState.isRoundReversed) status += '🔄11バック中 ';
            if (myRank) {
                gameActionsArea.innerHTML = `<p class="text-lg font-bold text-yellow-300">あなたは ${myRank} 位です！</p>`;
                status = 'ゲーム終了！';
            } else if (gameData.gameState.subTurn && gameData.gameState.subTurn.player === userId) {
                const sub = gameData.gameState.subTurn;
                const actionText = sub.type === 'SEVEN_PASS' ? '渡す' : '捨てる';
                status = `${actionText}カードを ${sub.count} 枚選択してください。`;
                gameActionsArea.innerHTML = `<button id="confirm-sub-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">決定</button>`;
                document.getElementById('confirm-sub-btn').addEventListener('click', () => {
                    const selected = Array.from(myHandAreaCards.querySelectorAll('.card.selected')).map(c => c.dataset.card);
                    if(selected.length !== sub.count) return showMessage(`${sub.count}枚選択してください。`);
                    const actionType = sub.type === 'SEVEN_PASS' ? 'PASS_CARDS' : 'DISCARD_CARDS';
                    GameManager.handleAction({ type: actionType, cards: selected });
                });
            } else if (gameData.gameState.turn === userId) {
                status += "あなたのターンです。";
                gameActionsArea.innerHTML = `<button id="play-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">出す</button>`;
                if(gameData.gameState.field.cards.length > 0) gameActionsArea.innerHTML += `<button id="pass-btn" class="ml-4 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">パス</button>`;
                document.getElementById('play-btn')?.addEventListener('click', () => {
                    const selected = Array.from(myHandAreaCards.querySelectorAll('.card.selected')).map(c => c.dataset.card);
                    if(selected.length > 0) GameManager.handleAction({ type: 'PLAY_CARDS', cards: selected });
                });
                document.getElementById('pass-btn')?.addEventListener('click', () => GameManager.handleAction({ type: 'PASS' }));
            } else {
                const currentActor = gameData.gameState.turn || gameData.gameState.subTurn?.player;
                status += `${gameData.players.find(p=>p.id === currentActor)?.name ?? ''}さんのターンです。`;
            }
            if (gameData.status === 'finished' && !myRank) {
                 const lastPlayer = gameData.players.find(p => !gameData.gameState.winners.some(w => w.id === p.id));
                 if(lastPlayer?.id === userId) {
                     gameActionsArea.innerHTML = `<p class="text-lg font-bold text-red-400">あなたはビリです！</p>`;
                 }
            }
            gameStatusMessage.textContent = status;
        };
        daifugoLogic.update = (gameData, action, playerId) => {
            let state = gameData.gameState;
            if ((state.turn !== playerId && state.subTurn?.player !== playerId) || state.winners.some(w => w.id === playerId)) return gameData;
            switch (action.type) {
                case 'PLAY_CARDS': {
                    if (state.subTurn) return gameData;
                    const { isValid, combination } = daifugoLogic.validatePlay(state, action.cards, playerId); if (!isValid) return gameData;
                    state.hands[playerId] = state.hands[playerId].filter(c => !action.cards.includes(c));
                    state.field = { cards: action.cards, player: playerId, suit: combination.suit };
                    state.passedPlayers = []; let flowReset = false;
                    if (state.rules.revolution && combination.isRevolution) state.isReversed = !state.isReversed;
                    if (state.rules.elevenBack && combination.rank === 11) state.isRoundReversed = !state.isRoundReversed;
                    if (state.rules.shibari) { state.isShibari = combination.suit && state.field.suit === combination.suit; state.shibariSuit = state.isShibari ? combination.suit : null; }
                    if (state.rules.eightCut && combination.rank === 8) { daifugoLogic.resetField(state, playerId); flowReset = true; }
                    if (state.hands[playerId].length === 0) { state.winners.push({ id: playerId, rank: state.winners.length + 1 }); }
                    if (gameData.players.filter(p => !state.winners.some(w => w.id === p.id)).length <= 1) return daifugoLogic.endGame(gameData);
                    if (state.rules.sevenPass && combination.rank === 7) { state.subTurn = { type: 'SEVEN_PASS', player: playerId, count: action.cards.length }; return gameData; }
                    if (state.rules.tenDiscard && combination.rank === 10) { state.subTurn = { type: 'TEN_DISCARD', player: playerId, count: action.cards.length }; return gameData; }
                    if(!flowReset) daifugoLogic.setNextTurn(gameData);
                    break;
                }
                case 'PASS': {
                    if (state.subTurn || state.field.cards.length === 0) return gameData;
                    state.passedPlayers.push(playerId); daifugoLogic.setNextTurn(gameData); break;
                }
                case 'PASS_CARDS': {
                    if (!state.subTurn || state.subTurn.type !== 'SEVEN_PASS' || state.subTurn.player !== playerId || action.cards.length !== state.subTurn.count) return gameData;
                    const currentIdx = gameData.players.findIndex(p => p.id === playerId);
                    let nextPlayerIdx = (currentIdx + 1) % gameData.players.length;
                    while(state.winners.some(w=>w.id === gameData.players[nextPlayerIdx].id)){ nextPlayerIdx = (nextPlayerIdx + 1) % gameData.players.length; }
                    const nextPlayerId = gameData.players[nextPlayerIdx].id;
                    state.hands[playerId] = state.hands[playerId].filter(c => !action.cards.includes(c));
                    state.hands[nextPlayerId].push(...action.cards);
                    state.subTurn = null;
                    if (state.hands[playerId].length === 0) { state.winners.push({ id: playerId, rank: state.winners.length + 1 }); }
                    daifugoLogic.setNextTurn(gameData); break;
                }
                case 'DISCARD_CARDS': {
                    if (!state.subTurn || state.subTurn.type !== 'TEN_DISCARD' || state.subTurn.player !== playerId || action.cards.length !== state.subTurn.count) return gameData;
                    state.hands[playerId] = state.hands[playerId].filter(c => !action.cards.includes(c));
                    state.subTurn = null;
                    if (state.hands[playerId].length === 0) { state.winners.push({ id: playerId, rank: state.winners.length + 1 }); }
                    daifugoLogic.setNextTurn(gameData); break;
                }
            }
            return gameData;
        };
        daifugoLogic.setNextTurn = (gameData) => {
            const state = gameData.gameState;
            const active = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
            if (active.length > 1 && state.passedPlayers.length >= active.length - 1) {
                 daifugoLogic.resetField(state, state.field.player); 
                 if (gameData.players.filter(p => !state.winners.some(w => w.id === p.id)).length <= 1) return daifugoLogic.endGame(gameData);
                 return; 
            }
            if (active.length <= 1) return daifugoLogic.endGame(gameData);
            const currentIdx = gameData.players.findIndex(p => p.id === state.turn);
            let nextIdx = (currentIdx + 1) % gameData.players.length;
            while (state.winners.some(w => w.id === gameData.players[nextIdx].id) || state.passedPlayers.includes(gameData.players[nextIdx].id)) {
                nextIdx = (nextIdx + 1) % gameData.players.length;
            }
            state.turn = gameData.players[nextIdx].id;
        };
        daifugoLogic.resetField = (state, nextPlayerId) => {
            state.field = { cards: [], player: null, suit: null }; state.passedPlayers = [];
            state.isShibari = false; state.shibariSuit = null; state.isRoundReversed = false;
            state.turn = nextPlayerId;
        };
        daifugoLogic.validatePlay = (state, cards) => {
            if (cards.length === 0) return { isValid: false };
            const getRank = c => c.startsWith('JOKER') ? 'JOKER' : parseInt(c.split('_')[1]);
            const getSuit = c => c.startsWith('JOKER') ? null : c.split('_')[0];
            const ranks = cards.map(getRank); const uniqueRanks = [...new Set(ranks.filter(r => r !== 'JOKER'))];
            if (uniqueRanks.length > 1) return { isValid: false }; // 階段は未実装
            const combination = { rank: uniqueRanks[0], suit: (cards.length === 1 || [...new Set(cards.map(getSuit))].length === 1) ? getSuit(cards[0]) : null, isRevolution: cards.length >= 4 };
            if (state.isShibari && combination.suit && combination.suit !== state.shibariSuit) return { isValid: false };
            if (state.field.cards.length > 0) {
                if(cards.length !== state.field.cards.length) return { isValid: false };
                const myStrength = daifugoLogic.getCardStrength(cards[0], state.isReversed, state.isRoundReversed);
                const fieldStrength = daifugoLogic.getCardStrength(state.field.cards[0], state.isReversed, state.isRoundReversed);
                if (myStrength <= fieldStrength) return { isValid: false };
            }
            return { isValid: true, combination };
        };
        daifugoLogic.endGame = (gameData) => {
            const state = gameData.gameState;
            const active = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
            if(active.length === 1) { state.winners.push({ id: active[0].id, rank: state.winners.length + 1 }); }
            gameData.status = 'finished'; state.turn = null; state.subTurn = null;
            return gameData;
        };
        daifugoLogic.handleLeave = (gameData, playerId) => {
            const state = gameData.gameState;
            if(!state.winners.some(w => w.id === playerId)) { state.winners.push({ id: playerId, rank: 99, left: true }); }
            if(state.turn === playerId) daifugoLogic.setNextTurn(gameData);
            else if(state.subTurn?.player === playerId) { state.subTurn = null; daifugoLogic.setNextTurn(gameData); }
            return gameData;
        };
        
        // ================== ばば抜きロジック詳細 ==================
        babanukiLogic.initialize = (gameData) => {
            const deck = CardUtils.shuffle(CardUtils.createDeck(1));
            const hands = CardUtils.deal(deck, gameData.players.length);
            const playerHands = {};
            gameData.players.forEach((p, i) => { playerHands[p.id] = babanukiLogic.removeInitialPairs(hands[i]); });
            const startingPlayer = gameData.players[Math.floor(Math.random() * gameData.players.length)].id;
            return { hands: playerHands, turn: startingPlayer, winners: [], hoverState: null, log: "ばば抜きスタート！" };
        };
        babanukiLogic.removeInitialPairs = (hand) => {
            const rankMap = new Map();
            hand.forEach(card => {
                const rank = card.startsWith('JOKER') ? 'JOKER' : card.split('_')[1];
                if (!rankMap.has(rank)) rankMap.set(rank, []);
                rankMap.get(rank).push(card);
            });
            const finalHand = [];
            for (const cards of rankMap.values()) {
                if (cards.length % 2 !== 0) finalHand.push(cards[0]);
            }
            return finalHand;
        };
        babanukiLogic.render = (gameData) => {
            GameManager.renderCommonLayout(gameData, (hand) => CardUtils.shuffle([...hand]));
            const { opponentsArea, myHandAreaCards, gameActionsArea, gameStatusMessage, tableArea } = allDomElements;
            tableArea.innerHTML = '';
            const state = gameData.gameState;
            const myRank = state.winners.find(w => w.id === userId)?.rank;
            let status = '';
            const activePlayers = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
            const turnPlayerIdxInActive = activePlayers.findIndex(p => p.id === state.turn);
            const targetPlayerOfTurn = activePlayers[(turnPlayerIdxInActive + activePlayers.length - 1) % activePlayers.length];

            if (gameData.status === 'finished') {
                status = 'ゲーム終了！';
                if (myRank > gameData.players.length) gameActionsArea.innerHTML = `<p class="text-lg font-bold text-red-400">あなたの負けです！</p>`;
                else gameActionsArea.innerHTML = `<p class="text-lg font-bold text-yellow-300">あなたは ${myRank} 位です！</p>`;
            } else if (myRank) {
                status = '勝ち抜け！他のプレイヤーを待っています...';
                gameActionsArea.innerHTML = `<p class="text-lg font-bold text-yellow-300">あなたは ${myRank} 位です！</p>`;
            } else if (state.turn === userId) {
                const targetPlayer = targetPlayerOfTurn;
                status = `${targetPlayer.name}さんからカードを1枚引いてください。`;
                const targetPlayerElement = opponentsArea.querySelector(`[data-player-id="${targetPlayer.id}"]`);
                if (targetPlayerElement) {
                    const cardContainer = targetPlayerElement.querySelector('.opponent-card-container');
                    cardContainer.innerHTML = '';
                    cardContainer.classList.add('interactive');
                    const targetHandSize = state.hands[targetPlayer.id]?.length || 0;
                    for (let i = 0; i < targetHandSize; i++) {
                        const cardEl = CardUtils.createCardElement('', false);
                        cardEl.style.cursor = 'pointer';
                        cardEl.addEventListener('click', () => GameManager.handleAction({ type: 'DRAW_CARD', targetPlayerId: targetPlayer.id, cardIndex: i }));
                        cardEl.addEventListener('mouseover', () => GameManager.handleAction({ type: 'HOVER_CARD', targetPlayerId: targetPlayer.id, cardIndex: i }));
                        cardEl.addEventListener('mouseout', () => GameManager.handleAction({ type: 'UNHOVER_CARD' }));
                        cardContainer.appendChild(cardEl);
                    }
                }
            } else {
                status = `${gameData.players.find(p => p.id === state.turn)?.name ?? ''}さんのターンです。`;
                if (targetPlayerOfTurn?.id === userId && state.hoverState) {
                     const cardElements = myHandAreaCards.querySelectorAll('.card');
                     if(cardElements[state.hoverState.cardIndex]) {
                        cardElements[state.hoverState.cardIndex].classList.add('hovered');
                     }
                }
            }
            gameStatusMessage.textContent = status;
        };
        babanukiLogic.update = (gameData, action, playerId) => {
            let state = gameData.gameState;
            if (action.type === 'HOVER_CARD' && state.turn === playerId) {
                gameData.gameState.hoverState = { targetPlayerId: action.targetPlayerId, cardIndex: action.cardIndex };
                return gameData;
            }
            if (action.type === 'UNHOVER_CARD' && state.turn === playerId) {
                gameData.gameState.hoverState = null;
                return gameData;
            }
            if (state.turn !== playerId || state.winners.some(w => w.id === playerId)) return gameData;
            if (action.type === 'DRAW_CARD') {
                state.hoverState = null;
                const targetHand = state.hands[action.targetPlayerId];
                if (!targetHand || targetHand.length === 0) return gameData;
                const drawnCardIndex = Math.floor(Math.random() * targetHand.length);
                const drawnCard = targetHand.splice(drawnCardIndex, 1)[0];
                const drawnRank = drawnCard.startsWith('JOKER') ? 'JOKER' : drawnCard.split('_')[1];
                const myHand = state.hands[playerId];
                const matchIndex = myHand.findIndex(card => (card.startsWith('JOKER') ? 'JOKER' : card.split('_')[1]) === drawnRank);
                if (matchIndex > -1) {
                    myHand.splice(matchIndex, 1);
                } else {
                    myHand.push(drawnCard);
                }
                if (state.hands[action.targetPlayerId].length === 0) {
                    state.winners.push({ id: action.targetPlayerId, rank: state.winners.length + 1 });
                }
                if (myHand.length === 0) {
                    state.winners.push({ id: playerId, rank: state.winners.length + 1 });
                }
                babanukiLogic.setNextTurn(gameData);
            }
            return gameData;
        };
        babanukiLogic.setNextTurn = (gameData) => {
            const state = gameData.gameState;
            const activePlayers = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
            if (activePlayers.length <= 1) {
                if (activePlayers.length === 1) state.winners.push({ id: activePlayers[0].id, rank: gameData.players.length + 1 });
                gameData.status = 'finished';
                state.turn = null;
                return;
            }
            const currentTurnPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
            let nextPlayerIndex = (currentTurnPlayerIndex + 1) % gameData.players.length;
            while (state.winners.some(w => w.id === gameData.players[nextPlayerIndex].id)) {
                nextPlayerIndex = (nextPlayerIndex + 1) % gameData.players.length;
            }
            state.turn = gameData.players[nextPlayerIndex].id;
        };
        babanukiLogic.handleLeave = (gameData, playerId) => {
            const state = gameData.gameState;
            if (!state.winners.some(w => w.id === playerId)) {
                state.winners.push({ id: playerId, rank: 99, left: true });
            }
            if (state.turn === playerId) {
                babanukiLogic.setNextTurn(gameData);
            }
            return gameData;
        };
        
        // ================== 神経衰弱ロジック詳細 ==================
        shinkeisuijakuLogic.initialize = (gameData) => {
            const deck = CardUtils.shuffle(CardUtils.createDeck(0));
            const boardCards = deck.map(card => ({ cardString: card, isFaceUp: false, isMatched: false }));
            const scores = gameData.players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
            return { boardCards, scores, turn: gameData.players[0].id, flippedIndices: [], winners: [] };
        };
        shinkeisuijakuLogic.render = (gameData) => {
            GameManager.renderCommonLayout(gameData);
            const { tableArea, gameActionsArea, gameStatusMessage, myHandAreaCards } = allDomElements;
            myHandAreaCards.innerHTML = `<p class="text-center w-full">あなたのスコア: ${gameData.gameState.scores[userId] ?? 0}</p>`;
            tableArea.innerHTML = '';
            tableArea.className = 'flex-grow flex flex-col items-center justify-center bg-green-700 rounded-lg p-2 shadow-inner mb-2 relative min-h-[140px] grid-layout';
            const state = gameData.gameState;
            state.boardCards.forEach((card, index) => {
                const cardEl = CardUtils.createCardElement(card.cardString, card.isFaceUp);
                if (card.isMatched) { cardEl.classList.add('matched'); }
                else if (!card.isFaceUp && state.turn === userId && state.flippedIndices.length < 2) {
                    cardEl.addEventListener('click', () => GameManager.handleAction({ type: 'FLIP_CARD', index }));
                }
                tableArea.appendChild(cardEl);
            });
            let status = '';
            if (gameData.status === 'finished') {
                let winnerText = 'ゲーム終了！';
                const maxScore = Math.max(...Object.values(state.scores));
                const winners = gameData.players.filter(p => state.scores[p.id] === maxScore);
                if (winners.length > 1) { winnerText += `勝者: ${winners.map(w => w.name).join(', ')} (引き分け)`; }
                else if (winners.length === 1) { winnerText += `勝者: ${winners[0].name}`; }
                status = winnerText;
            } else if (state.turn === userId) {
                status = `あなたのターンです。カードを${2 - state.flippedIndices.length}枚めくってください。`;
            } else {
                status = `${gameData.players.find(p => p.id === state.turn)?.name ?? ''}さんのターンです。`;
            }
            gameStatusMessage.textContent = status;
            if (state.flippedIndices.length === 2 && state.turn === userId) {
                const card1 = state.boardCards[state.flippedIndices[0]];
                const card2 = state.boardCards[state.flippedIndices[1]];
                const rank1 = card1.cardString.split('_')[1];
                const rank2 = card2.cardString.split('_')[1];
                if (rank1 !== rank2) {
                    clearTimeout(clientSideTimer);
                    clientSideTimer = setTimeout(() => { GameManager.handleAction({ type: 'CHECK_PAIR' }); }, 1000);
                }
            }
        };
        shinkeisuijakuLogic.update = (gameData, action, playerId) => {
            let state = gameData.gameState;
            if (state.turn !== playerId) return gameData;
            if (action.type === 'FLIP_CARD') {
                if (state.flippedIndices.length >= 2 || state.boardCards[action.index].isFaceUp) { return gameData; }
                state.boardCards[action.index].isFaceUp = true;
                state.flippedIndices.push(action.index);
                if (state.flippedIndices.length === 2) {
                    const card1 = state.boardCards[state.flippedIndices[0]];
                    const card2 = state.boardCards[state.flippedIndices[1]];
                    const rank1 = card1.cardString.split('_')[1];
                    const rank2 = card2.cardString.split('_')[1];
                    if (rank1 === rank2) {
                        card1.isMatched = true; card2.isMatched = true; state.scores[playerId]++; state.flippedIndices = [];
                        if (state.boardCards.every(c => c.isMatched)) { gameData.status = 'finished'; }
                    }
                }
            } else if (action.type === 'CHECK_PAIR') {
                state.boardCards[state.flippedIndices[0]].isFaceUp = false; state.boardCards[state.flippedIndices[1]].isFaceUp = false;
                state.flippedIndices = [];
                shinkeisuijakuLogic.setNextTurn(gameData);
            }
            return gameData;
        };
        shinkeisuijakuLogic.setNextTurn = (gameData) => {
            const state = gameData.gameState;
            const currentPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
            state.turn = gameData.players[(currentPlayerIndex + 1) % gameData.players.length].id;
        };
         shinkeisuijakuLogic.handleLeave = (gameData, playerId) => {
            if(gameData.gameState.turn === playerId) { shinkeisuijakuLogic.setNextTurn(gameData); }
            return gameData;
        };
        
        // ================== ダウトロジック詳細 ==================
        doubtLogic.initialize = (gameData) => {
            const deck = CardUtils.shuffle(CardUtils.createDeck(0));
            const hands = CardUtils.deal(deck, gameData.players.length);
            const playerHands = {};
            let startingPlayer = null;
            gameData.players.forEach((p, i) => { 
                playerHands[p.id] = hands[i]; 
                if(hands[i].includes('S_1')) startingPlayer = p.id;
            });
            return {
                hands: playerHands,
                turn: startingPlayer || gameData.players[0].id,
                field: [],
                expectedRank: 1,
                lastPlay: null, // {playerId, claimedRank, count}
                winners: [],
                log: "ダウトスタート！"
            };
        };
        doubtLogic.sortHand = (hand) => hand.sort((a,b) => parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
        doubtLogic.render = (gameData) => {
            GameManager.renderCommonLayout(gameData, doubtLogic.sortHand);
            const { tableArea, gameActionsArea, gameStatusMessage, myHandAreaCards } = allDomElements;
            const state = gameData.gameState;
            
            tableArea.innerHTML = '';
            if(state.field.length > 0) {
                const pile = document.createElement('div');
                pile.className = 'relative';
                const totalCards = state.field.reduce((sum, play) => sum + play.cards.length, 0);
                pile.appendChild(CardUtils.createCardElement('', false));
                pile.innerHTML += `<div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-2xl font-bold text-white">${totalCards}</div>`;
                tableArea.appendChild(pile);
            } else {
                tableArea.innerHTML = '<p class="text-gray-300">場にカードはありません</p>';
            }
            
            myHandAreaCards.querySelectorAll('.card').forEach(c => c.onclick = () => c.classList.toggle('selected'));
            gameActionsArea.innerHTML = '';
            
            const myRank = state.winners.find(w => w.id === userId)?.rank;
            if(myRank === 1) {
                gameActionsArea.innerHTML = '<p class="text-lg font-bold text-yellow-300">あなたの勝ちです！</p>';
            } else if (state.turn === userId) {
                gameActionsArea.innerHTML = '<button id="play-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">出す</button>';
                document.getElementById('play-btn')?.addEventListener('click', () => {
                    const selected = Array.from(myHandAreaCards.querySelectorAll('.card.selected')).map(c => c.dataset.card);
                    if (selected.length > 0) GameManager.handleAction({ type: 'PLAY_CARDS', cards: selected });
                    else showMessage('出すカードを1枚以上選択してください。');
                });
            } else if (state.lastPlay && state.lastPlay.playerId !== userId) {
                 gameActionsArea.innerHTML = '<button id="doubt-btn" class="ml-4 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">ダウト！</button>';
                 document.getElementById('doubt-btn')?.addEventListener('click', () => GameManager.handleAction({ type: 'CALL_DOUBT' }));
            }

            let status = state.log;
            if(gameData.status !== 'finished') {
                const rankDisplay = RANK_DISPLAY_MAP[state.expectedRank] || state.expectedRank;
                if (state.turn === userId) {
                     status = `あなたのターンです。「${rankDisplay}」を出してください。`;
                } else {
                    status = `${gameData.players.find(p=>p.id === state.turn)?.name ?? ''}さんのターンです。(次は${rankDisplay})`;
                }
            }
            gameStatusMessage.textContent = status;
        };
        doubtLogic.update = (gameData, action, playerId) => {
            let state = gameData.gameState;
            if (state.winners.some(w => w.id === playerId)) return gameData;
            switch (action.type) {
                case 'PLAY_CARDS': {
                    if (state.turn !== playerId) return gameData;
                    state.hands[playerId] = state.hands[playerId].filter(c => !action.cards.includes(c));
                    const playData = { cards: action.cards, playerId: playerId, claimedRank: state.expectedRank, count: action.cards.length };
                    state.field.push(playData);
                    state.lastPlay = playData;
                    const rankDisplay = RANK_DISPLAY_MAP[state.expectedRank] || state.expectedRank;
                    state.log = `${gameData.players.find(p=>p.id === playerId).name}が「${rankDisplay}」を${action.cards.length}枚出しました。`;
                    if (state.hands[playerId].length === 0) {
                        state.winners.push({ id: playerId, rank: 1 });
                        gameData.status = 'finished';
                        state.log = `${gameData.players.find(p=>p.id === playerId).name}があがりました！`;
                        return gameData;
                    }
                    doubtLogic.setNextTurn(gameData);
                    break;
                }
                case 'CALL_DOUBT': {
                    if (state.turn === playerId || !state.lastPlay) return gameData;
                    const lastPlay = state.lastPlay;
                    const lastPlayerId = lastPlay.playerId;
                    const isLie = lastPlay.cards.some(c => parseInt(c.split('_')[1]) !== lastPlay.claimedRank);
                    const allFieldCards = state.field.flatMap(p => p.cards);
                    
                    let penaltyPlayerId, logMsg;
                    if (isLie) { // ダウト成功
                        penaltyPlayerId = lastPlayerId;
                        logMsg = `${gameData.players.find(p=>p.id===playerId).name}のダウト成功！ ${gameData.players.find(p=>p.id===lastPlayerId).name}が場のカードを全て引き取ります。`;
                    } else { // ダウト失敗
                        penaltyPlayerId = playerId;
                        logMsg = `${gameData.players.find(p=>p.id===playerId).name}のダウト失敗！場のカードを全て引き取ります。`;
                    }
                    
                    state.hands[penaltyPlayerId].push(...allFieldCards);
                    state.field = [];
                    state.lastPlay = null;
                    state.log = logMsg;
                    
                    if (isLie) { // 成功時はダウトした人からターン開始
                        state.turn = playerId;
                    } else { // 失敗時は場のカードを出した人からターン再開
                       state.turn = lastPlayerId;
                       doubtLogic.setNextTurn(gameData);
                    }
                    break;
                }
            }
            return gameData;
        };
        doubtLogic.setNextTurn = (gameData) => {
            const state = gameData.gameState;
            const currentPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
            let nextPlayerIndex = (currentPlayerIndex + 1) % gameData.players.length;
            while (state.winners.some(w => w.id === gameData.players[nextPlayerIndex].id)) {
                nextPlayerIndex = (nextPlayerIndex + 1) % gameData.players.length;
            }
            state.turn = gameData.players[nextPlayerIndex].id;
            state.expectedRank = (state.expectedRank % 13) + 1;
        };
        doubtLogic.handleLeave = (gameData, playerId) => {
            if(gameData.gameState.turn === playerId) {
                doubtLogic.setNextTurn(gameData);
            }
            return gameData;
        };
        
        window.onload = initialize;
    </script>
</body>
</html>

