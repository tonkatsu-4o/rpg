<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒˆãƒ©ãƒ³ãƒ—ã‚²ãƒ¼ãƒ </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            overscroll-behavior: none; /* ã‚¹ãƒ¯ã‚¤ãƒ—ã§ã®ãƒšãƒ¼ã‚¸ã®æˆ»ã‚‹/é€²ã‚€ã‚’ç„¡åŠ¹åŒ– */
            touch-action: manipulation; /* ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ ã‚’ç„¡åŠ¹åŒ– */
        }
        .screen { display: none; }
        .screen.active { display: flex; flex-direction: column; }
        
        /* ã‚«ãƒ¼ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .card {
            width: 70px;
            height: 98px;
            border-radius: 6px;
            background-color: white;
            border: 1px solid #B0B0B0;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            position: relative;
            user-select: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 4px 8px 10px rgba(0,0,0,0.2); }
        .card.red { color: #D92D20; }
        .card.black { color: #101828; }
        .card .rank { position: absolute; top: 4px; left: 6px; font-size: 14px; }
        .card .suit { font-size: 28px; }
        .card .suit-sm { position: absolute; bottom: 4px; right: 6px; font-size: 14px; transform: rotate(180deg); }
        .card.back {
            background-image:
                linear-gradient(45deg, #4477ff 25%, transparent 25%),
                linear-gradient(-45deg, #4477ff 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #4477ff 75%),
                linear-gradient(-45deg, transparent 75%, #4477ff 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #3366ee;
        }
        .card.selected, .card.hovered { transform: translateY(-15px); border: 2px solid #3b82f6; }
        .card.disabled { opacity: 0.5; cursor: not-allowed; }
        .card.matched { visibility: hidden; }
        
        /* æ‰‹æœ­ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        #my-hand-area-cards {
            display: flex;
            flex-wrap: nowrap; /* ã‚¹ãƒãƒ›ã§æ‰‹æœ­ãŒæŠ˜ã‚Šè¿”ã•ãªã„ã‚ˆã†ã« */
            overflow-x: auto; /* æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å¯èƒ½ã« */
            justify-content: flex-start; /* å·¦è©°ã‚ */
            align-items: center;
            padding: 10px;
            -webkit-overflow-scrolling: touch; /* iOSã§ã®æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
        }
        #my-hand-area-cards .card {
            flex-shrink: 0; /* ã‚«ãƒ¼ãƒ‰ãŒç¸®ã¾ãªã„ã‚ˆã†ã« */
            margin-left: -30px;
        }
        #my-hand-area-cards .card:first-child { margin-left: 0; }

        .opponent-card-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .opponent-card-container.interactive .card {
            margin: 0 -15px 0 0 !important;
        }
        
        #table-area.grid-layout {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(65px, 1fr));
            gap: 8px;
            padding: 8px;
            width: 100%;
            height: 100%;
            overflow-y: auto;
        }
        #table-area.grid-layout .card {
            width: 100%;
            height: 80px; /* Adjust height for grid */
        }
    </style>
</head>
<body class="bg-gray-100 antialiased">

    <div id="app-container" class="max-w-md mx-auto min-h-screen bg-white shadow-lg">

        <!-- ===== ãƒ›ãƒ¼ãƒ ç”»é¢ ===== -->
        <div id="home-screen" class="screen active p-6">
            <header class="text-center mb-8">
                <h1 class="text-3xl font-bold text-gray-800">ãƒˆãƒ©ãƒ³ãƒ—ã‚²ãƒ¼ãƒ </h1>
                <p class="text-gray-500 mt-2">éŠã³ãŸã„ã‚²ãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„</p>
            </header>
            <div class="space-y-4">
                <button data-game="daifugo" class="game-select-btn w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">å¤§å¯Œè±ª</button>
                <button data-game="babanuki" class="game-select-btn w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">ã°ã°æŠœã</button>
                <button data-game="shinkeisuijaku" class="game-select-btn w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">ç¥çµŒè¡°å¼±</button>
                <button data-game="doubt" class="game-select-btn w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">ãƒ€ã‚¦ãƒˆ</button>
            </div>
             <div class="mt-8 text-center">
                <p class="text-sm text-gray-400">ã‚ãªãŸã®ID:</p>
                <p id="user-id-display" class="text-xs text-gray-500 bg-gray-100 p-2 rounded break-all"></p>
            </div>
        </div>

        <!-- ===== ãƒ­ãƒ“ãƒ¼ç”»é¢ ===== -->
        <div id="lobby-screen" class="screen p-6">
            <header class="text-center mb-6 relative">
                <h1 id="lobby-title" class="text-2xl font-bold text-gray-800"></h1>
                <button id="back-to-home-btn" class="absolute top-0 left-0 text-gray-500 hover:text-gray-800 p-2">&larr; æˆ»ã‚‹</button>
                <p class="text-gray-500 mt-1">å‹é”ã¨ã‚³ãƒ¼ãƒ‰ã‚’å…±æœ‰ã—ã¦å‚åŠ è€…ã‚’é›†ã‚ã‚ˆã†</p>
            </header>
            <div id="join-create-section">
                <div class="space-y-4">
                     <button id="create-game-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">æ–°ã—ã„ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</button>
                    <div class="relative flex items-center justify-center text-gray-400"><span class="px-2 bg-white">ã¾ãŸã¯</span></div>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="join-code-input" placeholder="å…±æœ‰ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›" class="flex-grow w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <button id="join-game-btn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-3 px-4 rounded-lg shadow-md">å‚åŠ </button>
                    </div>
                </div>
                <!-- å¤§å¯Œè±ªãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«è¨­å®š -->
                <div id="daifugo-rules-section" class="hidden mt-6 p-4 border rounded-lg bg-gray-50">
                    <h3 class="font-bold mb-3 text-gray-800 flex justify-between items-center">
                        <span>å¤§å¯Œè±ªãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«è¨­å®š</span>
                        <button id="rule-info-btn" class="text-sm text-blue-500 hover:underline">ãƒ«ãƒ¼ãƒ«èª¬æ˜</button>
                    </h3>
                    <div id="daifugo-rules-list" class="space-y-2 text-sm text-gray-700 grid grid-cols-2 gap-x-4 gap-y-2">
                        <!-- ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒJSã§ã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                    </div>
                </div>
            </div>
            <div id="waiting-room-section" class="hidden">
                <div class="text-center mb-6">
                    <p class="text-gray-600">å…±æœ‰ã‚³ãƒ¼ãƒ‰</p>
                    <div class="bg-gray-100 p-4 rounded-lg mt-2 flex items-center justify-center">
                        <p id="share-code-display" class="text-3xl font-bold tracking-widest text-gray-800"></p>
                        <button id="copy-code-btn" class="ml-4 p-2 rounded-lg bg-gray-200 hover:bg-gray-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                    </div>
                </div>
                <div class="mb-6"><h2 class="text-xl font-bold text-gray-700 mb-3">å‚åŠ è€…</h2><div id="player-list" class="space-y-2"></div></div>
                <div class="mt-8 space-y-4">
                     <button id="start-game-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
                    <button id="leave-game-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg shadow-md">ãƒ«ãƒ¼ãƒ ã‚’æŠœã‘ã‚‹</button>
                </div>
            </div>
        </div>

        <!-- ===== ã‚²ãƒ¼ãƒ ç”»é¢ ===== -->
        <div id="game-screen" class="screen p-2 md:p-4 bg-green-800 min-h-screen text-white">
            <div id="game-header" class="flex justify-between items-center mb-2 p-2 bg-black bg-opacity-20 rounded-lg">
                <h2 id="game-title" class="text-xl font-bold"></h2>
                <button id="leave-game-ingame-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg text-sm">ãƒ«ãƒ¼ãƒ é€€å‡º</button>
            </div>
            <div id="opponents-area" class="flex justify-around items-start flex-wrap gap-2 mb-2 min-h-[100px]"></div>
            <div id="table-area" class="flex-grow flex flex-col items-center justify-center bg-green-700 rounded-lg p-2 shadow-inner mb-2 relative min-h-[140px]"></div>
            <div id="my-info-area" class="flex flex-col items-center justify-center">
                <div id="my-hand-area-cards" class="w-full min-h-[120px]"></div>
                <div id="game-actions-area" class="mt-2 h-10"></div>
            </div>
            <div id="game-status-message" class="text-center font-semibold p-2 bg-black bg-opacity-30 rounded-lg mt-2"></div>
        </div>

        <!-- ===== ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« ===== -->
        <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-sm w-11/12 text-center">
                <p id="message-text" class="text-lg text-gray-800"></p>
                <button id="close-message-btn" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">OK</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, arrayUnion, arrayRemove, writeBatch, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- å®šæ•°ã¨è¨­å®š ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyDrgRoyNxnXHia1ASG1dup-hm2p4D0IpGw",
            authDomain: "card-game-platform-f967a.firebaseapp.com",
            projectId: "card-game-platform-f967a",
            storageBucket: "card-game-platform-f967a.firebasestorage.app",
            messagingSenderId: "165676867683",
            appId: "1:165676867683:web:dfd9677b260edf12161856",
            measurementId: "G-HK9L7PR991"
        };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-card-game-app';
        const GAME_NAMES = { daifugo: "å¤§å¯Œè±ª", babanuki: "ã°ã°æŠœã", shinkeisuijaku: "ç¥çµŒè¡°å¼±", doubt: "ãƒ€ã‚¦ãƒˆ" };
        const MIN_PLAYERS = { daifugo: 2, babanuki: 2, shinkeisuijaku: 2, doubt: 2 };
        const MAX_PLAYERS = { daifugo: 6, babanuki: 8, shinkeisuijaku: 6, doubt: 8 };
        const SUITS = ['H', 'D', 'C', 'S'];
        const RANKS = Array.from({ length: 13 }, (_, i) => i + 1); // 1(A) to 13(K)
        const RANK_DISPLAY_MAP = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K' };
        const DAIFUGO_RULES = {
            eightCut: { label: "8åˆ‡ã‚Š", default: true, description: "8ã‚’å‡ºã™ã¨å ´ãŒæµã‚Œã¾ã™ã€‚" },
            elevenBack: { label: "11ãƒãƒƒã‚¯", default: true, description: "J(11)ã‚’å‡ºã™ã¨ã‚«ãƒ¼ãƒ‰ã®å¼·ã•ãŒä¸€æ™‚çš„ã«é€†è»¢ã—ã¾ã™ã€‚" },
            shibari: { label: "ã—ã°ã‚Š", default: true, description: "å‰ã®äººã¨åŒã˜ã‚¹ãƒ¼ãƒˆã®ã‚«ãƒ¼ãƒ‰ãŒç¶šãã¨ã€ä»¥é™ãã®ã‚¹ãƒ¼ãƒˆã—ã‹å‡ºã›ãªããªã‚Šã¾ã™ã€‚" },
            revolution: { label: "é©å‘½", default: true, description: "åŒã˜æ•°å­—4æšä»¥ä¸Šã§ã‚«ãƒ¼ãƒ‰ã®å¼·ã•ãŒæ°¸ç¶šçš„ã«é€†è»¢ã—ã¾ã™ã€‚" },
            sevenPass: { label: "7æ¸¡ã—", default: false, description: "å‡ºã—ãŸ7ã®æšæ•°åˆ†ã€æ¬¡ã®äººã«æ‰‹æœ­ã‚’æ¸¡ã›ã¾ã™ã€‚" },
            tenDiscard: { label: "10æ¨ã¦", default: false, description: "å‡ºã—ãŸ10ã®æšæ•°åˆ†ã€æ‰‹æœ­ã‚’æ¨ã¦ã‚‰ã‚Œã¾ã™ã€‚" },
        };

        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
        let app, auth, db;
        let userId, userDisplayName;
        let currentGameId = null;
        let selectedGameType = null;
        let gameUnsubscribe = null;
        let localGameState = {};
        let clientSideTimer = null;

        // --- DOMè¦ç´  ---
        const screens = { home: document.getElementById('home-screen'), lobby: document.getElementById('lobby-screen'), game: document.getElementById('game-screen') };
        const allDomElements = {
            userIdDisplay: document.getElementById('user-id-display'),
            lobbyTitle: document.getElementById('lobby-title'),
            createGameBtn: document.getElementById('create-game-btn'),
            joinCodeInput: document.getElementById('join-code-input'),
            joinGameBtn: document.getElementById('join-game-btn'),
            joinCreateSection: document.getElementById('join-create-section'),
            waitingRoomSection: document.getElementById('waiting-room-section'),
            shareCodeDisplay: document.getElementById('share-code-display'),
            playerList: document.getElementById('player-list'),
            startGameBtn: document.getElementById('start-game-btn'),
            leaveGameBtn: document.getElementById('leave-game-btn'),
            copyCodeBtn: document.getElementById('copy-code-btn'),
            messageModal: document.getElementById('message-modal'),
            messageText: document.getElementById('message-text'),
            closeMessageBtn: document.getElementById('close-message-btn'),
            backToHomeBtn: document.getElementById('back-to-home-btn'),
            daifugoRulesSection: document.getElementById('daifugo-rules-section'),
            daifugoRulesList: document.getElementById('daifugo-rules-list'),
            ruleInfoBtn: document.getElementById('rule-info-btn'),
            gameTitle: document.getElementById('game-title'),
            leaveGameIngameBtn: document.getElementById('leave-game-ingame-btn'),
            opponentsArea: document.getElementById('opponents-area'),
            tableArea: document.getElementById('table-area'),
            myHandAreaCards: document.getElementById('my-hand-area-cards'),
            gameActionsArea: document.getElementById('game-actions-area'),
            gameStatusMessage: document.getElementById('game-status-message'),
        };

        // --- åˆæœŸåŒ– & èªè¨¼ ---
        async function initialize() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            onAuthStateChanged(auth, user => handleAuthState(user));
            setupEventListeners();
            setupDaifugoRules();
        }

        async function handleAuthState(user) {
            if (user) {
                userId = user.uid;
                userDisplayName = `Player-${userId.substring(0, 4)}`;
                allDomElements.userIdDisplay.textContent = userId;
            } else {
                try {
                    await (typeof __initial_auth_token !== 'undefined' && __initial_auth_token
                        ? signInWithCustomToken(auth, __initial_auth_token)
                        : signInAnonymously(auth));
                } catch (error) { console.error("Authentication failed:", error); showMessage("èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); }
            }
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š ---
        function setupEventListeners() {
            document.querySelectorAll('.game-select-btn').forEach(btn => btn.addEventListener('click', handleGameSelect));
            allDomElements.createGameBtn.addEventListener('click', createGame);
            allDomElements.joinGameBtn.addEventListener('click', joinGame);
            allDomElements.leaveGameBtn.addEventListener('click', leaveGame);
            allDomElements.leaveGameIngameBtn.addEventListener('click', leaveGame);
            allDomElements.startGameBtn.addEventListener('click', startGame);
            allDomElements.copyCodeBtn.addEventListener('click', copyShareCode);
            allDomElements.closeMessageBtn.addEventListener('click', () => allDomElements.messageModal.classList.add('hidden'));
            allDomElements.backToHomeBtn.addEventListener('click', resetLobby);
            allDomElements.ruleInfoBtn.addEventListener('click', showDaifugoRuleInfo);
        }
        
        // --- ç”»é¢é·ç§» & UIãƒ˜ãƒ«ãƒ‘ãƒ¼ ---
        const showScreen = (screenName) => { Object.values(screens).forEach(s => s.classList.remove('active')); screens[screenName].classList.add('active'); };
        const showMessage = (message, isHtml = false) => { 
            if(isHtml) allDomElements.messageText.innerHTML = message;
            else allDomElements.messageText.textContent = message;
            allDomElements.messageModal.classList.remove('hidden'); 
        };
        const generateGameId = () => Array(6).fill(0).map(() => 'ABCDEFGHIJKLMNPQRSTUVWXYZ123456789'[Math.floor(Math.random() * 35)]).join('');

        // --- ãƒ›ãƒ¼ãƒ ç”»é¢ãƒ­ã‚¸ãƒƒã‚¯ ---
        function handleGameSelect(e) {
            if (!auth.currentUser) return showMessage("ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
            selectedGameType = e.currentTarget.dataset.game;
            allDomElements.lobbyTitle.textContent = `${GAME_NAMES[selectedGameType]} ã®ãƒ­ãƒ“ãƒ¼`;
            allDomElements.daifugoRulesSection.classList.toggle('hidden', selectedGameType !== 'daifugo');
            showScreen('lobby');
        }

        // --- å¤§å¯Œè±ªãƒ«ãƒ¼ãƒ«è¨­å®š ---
        function setupDaifugoRules() {
            const listEl = allDomElements.daifugoRulesList;
            listEl.innerHTML = '';
            for (const ruleKey in DAIFUGO_RULES) {
                const rule = DAIFUGO_RULES[ruleKey];
                const labelEl = document.createElement('label');
                labelEl.className = 'flex items-center space-x-2 cursor-pointer';
                labelEl.innerHTML = `<input type="checkbox" name="${ruleKey}" ${rule.default ? 'checked' : ''} class="rounded text-blue-500 focus:ring-blue-500"><span>${rule.label}</span>`;
                listEl.appendChild(labelEl);
            }
        }
        function getSelectedDaifugoRules() {
            const rules = {};
            document.querySelectorAll('#daifugo-rules-list input[type="checkbox"]').forEach(checkbox => { rules[checkbox.name] = checkbox.checked; });
            return rules;
        }
        function showDaifugoRuleInfo() {
            let infoText = '<ul class="text-left list-disc pl-5 space-y-2">';
            for(const key in DAIFUGO_RULES) { infoText += `<li><strong>${DAIFUGO_RULES[key].label}:</strong> ${DAIFUGO_RULES[key].description}</li>`; }
            infoText += '</ul>';
            showMessage(infoText, true);
        }

        // --- ãƒ­ãƒ“ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯ ---
        async function createGame() {
            const gameId = generateGameId(); currentGameId = gameId;
            const hostPlayer = { id: userId, name: userDisplayName, isHost: true, rank: 'heimin' };
            const gameDoc = { gameType: selectedGameType, hostId: userId, players: [hostPlayer], status: 'waiting', createdAt: new Date() };
            if (selectedGameType === 'daifugo') gameDoc.rules = getSelectedDaifugoRules();
            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
                await setDoc(gameRef, gameDoc);
                listenToGameUpdates(gameId);
                allDomElements.joinCreateSection.classList.add('hidden'); allDomElements.waitingRoomSection.classList.remove('hidden');
            } catch (error) { console.error("Error creating game:", error); showMessage("ã‚²ãƒ¼ãƒ ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); }
        }

        async function joinGame() {
            const gameId = allDomElements.joinCodeInput.value.toUpperCase().trim();
            if (!gameId) return showMessage("å…±æœ‰ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
            try {
                const gameDoc = await getDoc(gameRef); if (!gameDoc.exists()) return showMessage("ãƒ«ãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                const gameData = gameDoc.data(); if (gameData.status !== 'waiting') return showMessage("ã“ã®ã‚²ãƒ¼ãƒ ã¯æ—¢ã«å‚åŠ ã§ãã¾ã›ã‚“ã€‚");
                if (gameData.players.length >= MAX_PLAYERS[gameData.gameType]) return showMessage("ã“ã®ãƒ«ãƒ¼ãƒ ã¯æº€å“¡ã§ã™ã€‚");
                if (!gameData.players.some(p => p.id === userId)) {
                    const newPlayer = { id: userId, name: userDisplayName, isHost: false, rank: 'heimin' };
                    await updateDoc(gameRef, { players: arrayUnion(newPlayer) });
                }
                currentGameId = gameId; selectedGameType = gameData.gameType;
                listenToGameUpdates(gameId);
                allDomElements.lobbyTitle.textContent = `${GAME_NAMES[selectedGameType]} ã®ãƒ­ãƒ“ãƒ¼`;
                allDomElements.daifugoRulesSection.classList.toggle('hidden', selectedGameType !== 'daifugo');
                allDomElements.joinCreateSection.classList.add('hidden'); allDomElements.waitingRoomSection.classList.remove('hidden');
            } catch (error) { console.error("Error joining game:", error); showMessage("ã‚²ãƒ¼ãƒ ã¸ã®å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); }
        }
        
        async function leaveGame() {
            if (!currentGameId || !userId) return;
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef); if (!gameDoc.exists()) return;
                    let gameData = gameDoc.data();
                    const remainingPlayers = gameData.players.filter(p => p.id !== userId);
                    if (remainingPlayers.length === 0) { transaction.delete(gameRef); }
                    else {
                        if (gameData.hostId === userId) { remainingPlayers[0].isHost = true; gameData.hostId = remainingPlayers[0].id; }
                        gameData.players = remainingPlayers;
                        if(gameData.status === 'playing') {
                           const logic = gameLogics[gameData.gameType];
                           if(logic?.handleLeave) gameData = logic.handleLeave(gameData, userId);
                        }
                        transaction.update(gameRef, gameData);
                    }
                });
            } catch (error) { console.error("Error leaving game:", error); }
            finally { resetLobby(); }
        }
        
        function resetLobby() {
            if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
            currentGameId = null; localGameState = {}; allDomElements.joinCodeInput.value = '';
            allDomElements.waitingRoomSection.classList.add('hidden'); allDomElements.joinCreateSection.classList.remove('hidden');
            showScreen('home');
        }

        function listenToGameUpdates(gameId) {
            if (gameUnsubscribe) gameUnsubscribe();
            const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, gameId);
            gameUnsubscribe = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) { showMessage("ãƒ«ãƒ¼ãƒ ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚"); resetLobby(); return; }
                const gameData = doc.data(); localGameState = gameData; 
                if (gameData.status === 'waiting') {
                    if (!screens.lobby.classList.contains('active')) showScreen('lobby');
                    updateLobbyUI(gameData);
                } else if (gameData.status === 'playing' || gameData.status === 'finished') {
                    if (!screens.game.classList.contains('active')) showScreen('game');
                    GameManager.renderGame(gameData);
                }
            });
        }
        
        function updateLobbyUI(gameData) {
            allDomElements.shareCodeDisplay.textContent = currentGameId; allDomElements.playerList.innerHTML = '';
            gameData.players.forEach(player => {
                const playerEl = document.createElement('div');
                playerEl.className = 'flex items-center justify-between p-3 bg-gray-100 rounded-lg';
                playerEl.innerHTML = `<span class="font-medium text-gray-700">${player.name} ${player.id === userId ? '(ã‚ãªãŸ)' : ''}</span><span class="text-sm font-semibold text-indigo-600">${player.isHost ? 'ãƒ›ã‚¹ãƒˆ' : ''}</span>`;
                allDomElements.playerList.appendChild(playerEl);
            });
            const isHost = gameData.hostId === userId;
            allDomElements.startGameBtn.style.display = isHost ? 'block' : 'none';
            if(isHost) {
                const min = MIN_PLAYERS[gameData.gameType]; const max = MAX_PLAYERS[gameData.gameType]; const playerCount = gameData.players.length;
                allDomElements.startGameBtn.disabled = !(playerCount >= min && playerCount <= max);
                if (playerCount < min) allDomElements.startGameBtn.textContent = `ã‚ã¨${min - playerCount}äººå¿…è¦ã§ã™`;
                else if (playerCount > max) allDomElements.startGameBtn.textContent = `${max}äººä»¥ä¸‹ã«ã—ã¦ãã ã•ã„`;
                else allDomElements.startGameBtn.textContent = 'ã‚²ãƒ¼ãƒ é–‹å§‹';
            }
        }
        
        async function copyShareCode() {
            const code = allDomElements.shareCodeDisplay.textContent;
            try { await navigator.clipboard.writeText(code); showMessage(`ã‚³ãƒ¼ãƒ‰ "${code}" ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚`); }
            catch (err) { console.error('Copy failed', err); showMessage("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); }
        }

        async function startGame() {
            if (localGameState.hostId !== userId) return;
            const newGameState = GameManager.initializeGame(localGameState);
            if(newGameState) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
                await updateDoc(gameRef, { status: 'playing', gameState: newGameState });
            }
        }

        // ========================================================================
        // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ ---
        // ========================================================================
        const CardUtils = {
            createDeck: (useJokers = 0) => {
                const deck = SUITS.flatMap(s => RANKS.map(r => `${s}_${r}`));
                for (let i = 0; i < useJokers; i++) deck.push(`JOKER_${i}`); return deck;
            },
            shuffle: (a) => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; },
            deal: (deck, numPlayers) => { const h = Array.from({ length: numPlayers }, () => []); deck.forEach((c, i) => h[i % numPlayers].push(c)); return h; },
            createCardElement: (cardString, faceUp = true) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card'; cardEl.dataset.card = cardString;
                if (!faceUp) { cardEl.classList.add('back'); return cardEl; }
                if (cardString.startsWith('JOKER')) { cardEl.innerHTML = `<span class="suit">ğŸƒ</span>`; return cardEl; }
                const [suitChar, rank] = cardString.split('_');
                const suitMap = { S: 'â™ ', H: 'â™¥', D: 'â™¦', C: 'â™£' }; const colorMap = { S: 'black', H: 'red', D: 'red', C: 'black' };
                const rankDisplay = RANK_DISPLAY_MAP[rank] || rank;
                cardEl.classList.add(colorMap[suitChar]);
                cardEl.innerHTML = `<div class="rank">${rankDisplay}</div><div class="suit">${suitMap[suitChar]}</div><div class="suit-sm">${suitMap[suitChar]}</div>`; return cardEl;
            }
        };

        const GameManager = {
            initializeGame: (gameData) => { const logic = gameLogics[gameData.gameType]; return logic?.initialize ? logic.initialize(gameData) : null; },
            renderGame: (gameData) => { allDomElements.gameTitle.textContent = GAME_NAMES[gameData.gameType]; const logic = gameLogics[gameData.gameType]; logic?.render?.(gameData); },
            handleAction: async (action) => {
                if (!currentGameId) return;
                const gameRef = doc(db, `artifacts/${appId}/public/data/card_games`, currentGameId);
                try {
                     const logic = gameLogics[localGameState.gameType];
                    // ãƒ›ãƒãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¤–ã§è»½é‡ã«å‡¦ç†
                    if (action.type === 'HOVER_CARD' || action.type === 'UNHOVER_CARD') {
                        if (logic?.update) {
                            const updatedData = logic.update(localGameState, action, userId);
                            if (updatedData) await updateDoc(gameRef, updatedData);
                        }
                        return;
                    }
                    await runTransaction(db, async (transaction) => {
                        const gameDoc = await transaction.get(gameRef);
                        if (!gameDoc.exists()) throw new Error("Game not found");
                        let currentData = gameDoc.data();
                        if (logic?.update) {
                            const updatedData = logic.update(currentData, action, userId);
                            if (updatedData) transaction.update(gameRef, updatedData);
                        }
                    });
                } catch (error) { console.error("Action failed:", error); showMessage("æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ: " + error.message); }
            },
            renderCommonLayout: (gameData, cardSortFn) => {
                const { opponentsArea, myHandAreaCards } = allDomElements;
                opponentsArea.innerHTML = ''; myHandAreaCards.innerHTML = '';
                const myPlayerIndex = gameData.players.findIndex(p => p.id === userId);
                if (myPlayerIndex === -1) return;
                gameData.players.forEach(player => {
                    if (player.id === userId) {
                        const myHand = gameData.gameState.hands?.[player.id] || [];
                        const sortedHand = cardSortFn ? cardSortFn(myHand, gameData.gameState) : myHand;
                        sortedHand.forEach(card => myHandAreaCards.appendChild(CardUtils.createCardElement(card)));
                    } else {
                        const opponentHand = gameData.gameState.hands?.[player.id] || [];
                        const opponentEl = document.createElement('div');
                        opponentEl.dataset.playerId = player.id;
                        const isTurn = gameData.gameState.turn === player.id || gameData.gameState.subTurn?.player === player.id;
                        opponentEl.className = `text-center p-2 rounded-lg ${isTurn ? 'bg-yellow-500 bg-opacity-30' : 'bg-black bg-opacity-20'}`;
                        const winnerRank = gameData.gameState.winners?.find(w => w.id === player.id)?.rank;
                        const rankText = winnerRank ? (winnerRank === 1 ? 'ğŸ‘‘ å‹ã¡' : (winnerRank > 90 ? 'âŒ' : `${winnerRank}ä½`)) : '';
                        const score = gameData.gameState.scores?.[player.id];
                        const scoreText = score !== undefined ? `<span class="text-xs">ã‚¹ã‚³ã‚¢: ${score}</span>` : '';

                        opponentEl.innerHTML = `
                            <p class="font-bold text-sm">${player.name} ${rankText}</p>
                            ${scoreText}
                            <div class="opponent-card-container mt-1">
                                ${opponentHand?.length > 0 ? `<div class="card back text-white text-2xl font-bold">${opponentHand.length}</div>` : ''}
                            </div>
                            <p class="text-xs mt-1 h-4">${gameData.gameState.passedPlayers?.includes(player.id) ? 'ãƒ‘ã‚¹' : ''}</p>`;
                        opponentsArea.appendChild(opponentEl);
                    }
                });
            }
        };
        
        // --- å„ã‚²ãƒ¼ãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ ---
        const gameLogics = {
            daifugo: null,
            babanuki: null,
            shinkeisuijaku: null,
            doubt: null,
        };
        
        // ================== å¤§å¯Œè±ªãƒ­ã‚¸ãƒƒã‚¯ ==================
        const daifugoLogic = { /* ... çœç•¥ ... */ };
        gameLogics.daifugo = daifugoLogic;

        // ================== ã°ã°æŠœããƒ­ã‚¸ãƒƒã‚¯ ==================
        const babanukiLogic = { /* ... çœç•¥ ... */ };
        gameLogics.babanuki = babanukiLogic;

        // ================== ç¥çµŒè¡°å¼±ãƒ­ã‚¸ãƒƒã‚¯ ==================
        const shinkeisuijakuLogic = { /* ... çœç•¥ ... */ };
        gameLogics.shinkeisuijaku = shinkeisuijakuLogic;
        
        // ================== ãƒ€ã‚¦ãƒˆãƒ­ã‚¸ãƒƒã‚¯ ==================
        const doubtLogic = {
            initialize: (gameData) => {
                const deck = CardUtils.shuffle(CardUtils.createDeck(0));
                const hands = CardUtils.deal(deck, gameData.players.length);
                const playerHands = {};
                let startingPlayer = null;
                gameData.players.forEach((p, i) => { 
                    playerHands[p.id] = hands[i]; 
                    if(hands[i].includes('S_1')) startingPlayer = p.id;
                });
                return {
                    hands: playerHands,
                    turn: startingPlayer || gameData.players[0].id,
                    field: [],
                    expectedRank: 1,
                    lastPlay: null, // {playerId, claimedRank, count}
                    winners: [],
                    log: "ãƒ€ã‚¦ãƒˆã‚¹ã‚¿ãƒ¼ãƒˆï¼"
                };
            },
            sortHand: (hand) => hand.sort((a,b) => parseInt(a.split('_')[1]) - parseInt(b.split('_')[1])),
            render: (gameData) => {
                GameManager.renderCommonLayout(gameData, doubtLogic.sortHand);
                const { tableArea, gameActionsArea, gameStatusMessage, myHandAreaCards } = allDomElements;
                const state = gameData.gameState;
                
                tableArea.innerHTML = '';
                if(state.field.length > 0) {
                    const pile = document.createElement('div');
                    pile.className = 'relative';
                    pile.appendChild(CardUtils.createCardElement('', false));
                    pile.innerHTML += `<div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-2xl font-bold text-white">${state.field.length}</div>`;
                    tableArea.appendChild(pile);
                } else {
                    tableArea.innerHTML = '<p class="text-gray-300">å ´ã«ã‚«ãƒ¼ãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“</p>';
                }
                
                myHandAreaCards.querySelectorAll('.card').forEach(c => c.onclick = () => c.classList.toggle('selected'));
                gameActionsArea.innerHTML = '';
                
                const myRank = state.winners.find(w => w.id === userId)?.rank;
                if(myRank === 1) {
                    gameActionsArea.innerHTML = '<p class="text-lg font-bold text-yellow-300">ã‚ãªãŸã®å‹ã¡ã§ã™ï¼</p>';
                } else if (state.turn === userId) {
                    gameActionsArea.innerHTML = '<button id="play-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">å‡ºã™</button>';
                    if (state.lastPlay) {
                        gameActionsArea.innerHTML += '<button id="doubt-btn" class="ml-4 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">ãƒ€ã‚¦ãƒˆï¼</button>';
                    }
                    document.getElementById('play-btn')?.addEventListener('click', () => {
                        const selected = Array.from(myHandAreaCards.querySelectorAll('.card.selected')).map(c => c.dataset.card);
                        if (selected.length > 0) GameManager.handleAction({ type: 'PLAY_CARDS', cards: selected });
                        else showMessage('å‡ºã™ã‚«ãƒ¼ãƒ‰ã‚’1æšä»¥ä¸Šé¸æŠã—ã¦ãã ã•ã„ã€‚');
                    });
                    document.getElementById('doubt-btn')?.addEventListener('click', () => GameManager.handleAction({ type: 'CALL_DOUBT' }));
                }

                let status = state.log;
                if(gameData.status !== 'finished') {
                    if (state.turn === userId) {
                         const rankDisplay = RANK_DISPLAY_MAP[state.expectedRank] || state.expectedRank;
                         status = `ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚ã€Œ${rankDisplay}ã€ã‚’å‡ºã—ã¦ãã ã•ã„ã€‚`;
                    } else {
                        status = `${gameData.players.find(p=>p.id === state.turn)?.name ?? ''}ã•ã‚“ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚`;
                    }
                }
                gameStatusMessage.textContent = status;
            },
            update: (gameData, action, playerId) => {
                let state = gameData.gameState;
                if (state.winners.some(w => w.id === playerId)) return gameData;

                switch (action.type) {
                    case 'PLAY_CARDS': {
                        if (state.turn !== playerId) return gameData;
                        state.hands[playerId] = state.hands[playerId].filter(c => !action.cards.includes(c));
                        const playData = { cards: action.cards, playerId: playerId, claimedRank: state.expectedRank, count: action.cards.length };
                        state.field.push(playData);
                        state.lastPlay = playData;
                        const rankDisplay = RANK_DISPLAY_MAP[state.expectedRank] || state.expectedRank;
                        state.log = `${userDisplayName}ãŒã€Œ${rankDisplay}ã€ã‚’${action.cards.length}æšå‡ºã—ã¾ã—ãŸã€‚`;
                        if (state.hands[playerId].length === 0) {
                            state.winners.push({ id: playerId, rank: 1 });
                            gameData.status = 'finished';
                            state.log = `${userDisplayName}ãŒã‚ãŒã‚Šã¾ã—ãŸï¼`;
                            return gameData;
                        }
                        doubtLogic.setNextTurn(gameData);
                        break;
                    }
                    case 'CALL_DOUBT': {
                        if (state.turn !== playerId || !state.lastPlay) return gameData;
                        const lastPlay = state.lastPlay;
                        const lastPlayerId = lastPlay.playerId;
                        const isLie = lastPlay.cards.some(c => parseInt(c.split('_')[1]) !== lastPlay.claimedRank);
                        const allFieldCards = state.field.flatMap(p => p.cards);
                        
                        let penaltyPlayerId, logMsg;
                        if (isLie) { // ãƒ€ã‚¦ãƒˆæˆåŠŸ
                            penaltyPlayerId = lastPlayerId;
                            logMsg = `${userDisplayName}ã®ãƒ€ã‚¦ãƒˆæˆåŠŸï¼ ${gameData.players.find(p=>p.id===lastPlayerId).name}ãŒå ´ã®ã‚«ãƒ¼ãƒ‰ã‚’å…¨ã¦å¼•ãå–ã‚Šã¾ã™ã€‚`;
                        } else { // ãƒ€ã‚¦ãƒˆå¤±æ•—
                            penaltyPlayerId = playerId;
                            logMsg = `${userDisplayName}ã®ãƒ€ã‚¦ãƒˆå¤±æ•—ï¼å ´ã®ã‚«ãƒ¼ãƒ‰ã‚’å…¨ã¦å¼•ãå–ã‚Šã¾ã™ã€‚`;
                        }
                        
                        state.hands[penaltyPlayerId].push(...allFieldCards);
                        state.field = [];
                        state.lastPlay = null;
                        state.log = logMsg;
                        
                        if (isLie) { // æˆåŠŸæ™‚ã¯ãƒ€ã‚¦ãƒˆã—ãŸäººã‹ã‚‰
                            state.turn = playerId;
                        } else { // å¤±æ•—æ™‚ã¯ãƒ€ã‚¦ãƒˆã—ãŸäººã®æ¬¡ã‹ã‚‰
                           doubtLogic.setNextTurn(gameData);
                        }
                        break;
                    }
                }
                return gameData;
            },
            setNextTurn: (gameData) => {
                const state = gameData.gameState;
                const currentPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
                let nextPlayerIndex = (currentPlayerIndex + 1) % gameData.players.length;
                while (state.winners.some(w => w.id === gameData.players[nextPlayerIndex].id)) {
                    nextPlayerIndex = (nextPlayerIndex + 1) % gameData.players.length;
                }
                state.turn = gameData.players[nextPlayerIndex].id;
                state.expectedRank = (state.expectedRank % 13) + 1;
            },
            handleLeave: (gameData, playerId) => {
                if(gameData.gameState.turn === playerId) {
                    doubtLogic.setNextTurn(gameData);
                }
                return gameData;
            }
        };

        gameLogics.babanuki = {
            initialize: (gameData) => {
                const deck = CardUtils.shuffle(CardUtils.createDeck(1));
                const hands = CardUtils.deal(deck, gameData.players.length);
                const playerHands = {};
                gameData.players.forEach((p, i) => { playerHands[p.id] = babanukiLogic.removeInitialPairs(hands[i]); });
                const startingPlayer = gameData.players[Math.floor(Math.random() * gameData.players.length)].id;
                return { hands: playerHands, turn: startingPlayer, winners: [], hoverState: null, log: "ã°ã°æŠœãã‚¹ã‚¿ãƒ¼ãƒˆï¼" };
            },
            removeInitialPairs: (hand) => {
                const rankMap = new Map();
                hand.forEach(card => {
                    const rank = card.startsWith('JOKER') ? 'JOKER' : card.split('_')[1];
                    if (!rankMap.has(rank)) rankMap.set(rank, []);
                    rankMap.get(rank).push(card);
                });
                const finalHand = [];
                for (const cards of rankMap.values()) {
                    if (cards.length % 2 !== 0) finalHand.push(cards[0]);
                }
                return finalHand;
            },
            render: (gameData) => {
                GameManager.renderCommonLayout(gameData, (hand) => CardUtils.shuffle([...hand]));
                const { opponentsArea, myHandAreaCards, gameActionsArea, gameStatusMessage, tableArea } = allDomElements;
                tableArea.innerHTML = '';
                const state = gameData.gameState;
                const myRank = state.winners.find(w => w.id === userId)?.rank;
                let status = '';
                const activePlayers = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
                const turnPlayerIdxInActive = activePlayers.findIndex(p => p.id === state.turn);
                const targetPlayerOfTurn = activePlayers[(turnPlayerIdxInActive + activePlayers.length - 1) % activePlayers.length];

                if (gameData.status === 'finished') {
                    status = 'ã‚²ãƒ¼ãƒ çµ‚äº†ï¼';
                    if (myRank > gameData.players.length) gameActionsArea.innerHTML = `<p class="text-lg font-bold text-red-400">ã‚ãªãŸã®è² ã‘ã§ã™ï¼</p>`;
                    else gameActionsArea.innerHTML = `<p class="text-lg font-bold text-yellow-300">ã‚ãªãŸã¯ ${myRank} ä½ã§ã™ï¼</p>`;
                } else if (myRank) {
                    status = 'å‹ã¡æŠœã‘ï¼ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾…ã£ã¦ã„ã¾ã™...';
                    gameActionsArea.innerHTML = `<p class="text-lg font-bold text-yellow-300">ã‚ãªãŸã¯ ${myRank} ä½ã§ã™ï¼</p>`;
                } else if (state.turn === userId) {
                    const targetPlayer = targetPlayerOfTurn;
                    status = `${targetPlayer.name}ã•ã‚“ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ã„ã¦ãã ã•ã„ã€‚`;
                    const targetPlayerElement = opponentsArea.querySelector(`[data-player-id="${targetPlayer.id}"]`);
                    if (targetPlayerElement) {
                        const cardContainer = targetPlayerElement.querySelector('.opponent-card-container');
                        cardContainer.innerHTML = '';
                        cardContainer.classList.add('interactive');
                        const targetHandSize = state.hands[targetPlayer.id]?.length || 0;
                        for (let i = 0; i < targetHandSize; i++) {
                            const cardEl = CardUtils.createCardElement('', false);
                            cardEl.style.cursor = 'pointer';
                            cardEl.addEventListener('click', () => GameManager.handleAction({ type: 'DRAW_CARD', targetPlayerId: targetPlayer.id, cardIndex: i }));
                            cardEl.addEventListener('mouseover', () => GameManager.handleAction({ type: 'HOVER_CARD', targetPlayerId: targetPlayer.id, cardIndex: i }));
                            cardEl.addEventListener('mouseout', () => GameManager.handleAction({ type: 'UNHOVER_CARD' }));
                            cardContainer.appendChild(cardEl);
                        }
                    }
                } else {
                    status = `${gameData.players.find(p => p.id === state.turn)?.name ?? ''}ã•ã‚“ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚`;
                    if (targetPlayerOfTurn?.id === userId && state.hoverState) {
                         const cardElements = myHandAreaCards.querySelectorAll('.card');
                         if(cardElements[state.hoverState.cardIndex]) {
                            cardElements[state.hoverState.cardIndex].classList.add('hovered');
                         }
                    }
                }
                gameStatusMessage.textContent = status;
            },
            update: (gameData, action, playerId) => {
                let state = gameData.gameState;
                if (action.type === 'HOVER_CARD' && state.turn === playerId) {
                    gameData.gameState.hoverState = { targetPlayerId: action.targetPlayerId, cardIndex: action.cardIndex };
                    return gameData;
                }
                if (action.type === 'UNHOVER_CARD' && state.turn === playerId) {
                    gameData.gameState.hoverState = null;
                    return gameData;
                }
                if (state.turn !== playerId || state.winners.some(w => w.id === playerId)) return gameData;
                if (action.type === 'DRAW_CARD') {
                    state.hoverState = null;
                    const targetHand = state.hands[action.targetPlayerId];
                    if (!targetHand || targetHand.length === 0) return gameData;
                    const drawnCardIndex = Math.floor(Math.random() * targetHand.length);
                    const drawnCard = targetHand.splice(drawnCardIndex, 1)[0];
                    const drawnRank = drawnCard.startsWith('JOKER') ? 'JOKER' : drawnCard.split('_')[1];
                    const myHand = state.hands[playerId];
                    const matchIndex = myHand.findIndex(card => (card.startsWith('JOKER') ? 'JOKER' : card.split('_')[1]) === drawnRank);
                    if (matchIndex > -1) {
                        myHand.splice(matchIndex, 1);
                    } else {
                        myHand.push(drawnCard);
                    }
                    if (state.hands[action.targetPlayerId].length === 0) {
                        state.winners.push({ id: action.targetPlayerId, rank: state.winners.length + 1 });
                    }
                    if (myHand.length === 0) {
                        state.winners.push({ id: playerId, rank: state.winners.length + 1 });
                    }
                    babanukiLogic.setNextTurn(gameData);
                }
                return gameData;
            },
            setNextTurn: (gameData) => {
                const state = gameData.gameState;
                const activePlayers = gameData.players.filter(p => !state.winners.some(w => w.id === p.id));
                if (activePlayers.length <= 1) {
                    if (activePlayers.length === 1) state.winners.push({ id: activePlayers[0].id, rank: gameData.players.length + 1 });
                    gameData.status = 'finished';
                    state.turn = null;
                    return;
                }
                const currentTurnPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
                let nextPlayerIndex = (currentTurnPlayerIndex + 1) % gameData.players.length;
                while (state.winners.some(w => w.id === gameData.players[nextPlayerIndex].id)) {
                    nextPlayerIndex = (nextPlayerIndex + 1) % gameData.players.length;
                }
                state.turn = gameData.players[nextPlayerIndex].id;
            },
            handleLeave: (gameData, playerId) => {
                const state = gameData.gameState;
                if (!state.winners.some(w => w.id === playerId)) {
                    state.winners.push({ id: playerId, rank: 99, left: true });
                }
                if (state.turn === playerId) {
                    babanukiLogic.setNextTurn(gameData);
                }
                return gameData;
            }
        };
        
        gameLogics.shinkeisuijaku = {
            initialize: (gameData) => {
                const deck = CardUtils.shuffle(CardUtils.createDeck(0));
                const boardCards = deck.map(card => ({ cardString: card, isFaceUp: false, isMatched: false }));
                const scores = gameData.players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                return { boardCards, scores, turn: gameData.players[0].id, flippedIndices: [], winners: [] };
            },
            render: (gameData) => {
                GameManager.renderCommonLayout(gameData);
                const { tableArea, gameActionsArea, gameStatusMessage, myHandAreaCards } = allDomElements;
                myHandAreaCards.innerHTML = `<p class="text-center w-full">ã‚ãªãŸã®ã‚¹ã‚³ã‚¢: ${gameData.gameState.scores[userId] ?? 0}</p>`;
                tableArea.innerHTML = '';
                tableArea.className = 'flex-grow flex flex-col items-center justify-center bg-green-700 rounded-lg p-2 shadow-inner mb-2 relative min-h-[140px] grid-layout';
                const state = gameData.gameState;
                state.boardCards.forEach((card, index) => {
                    const cardEl = CardUtils.createCardElement(card.cardString, card.isFaceUp);
                    if (card.isMatched) { cardEl.classList.add('matched'); }
                    else if (!card.isFaceUp && state.turn === userId && state.flippedIndices.length < 2) {
                        cardEl.addEventListener('click', () => GameManager.handleAction({ type: 'FLIP_CARD', index }));
                    }
                    tableArea.appendChild(cardEl);
                });
                let status = '';
                if (gameData.status === 'finished') {
                    let winnerText = 'ã‚²ãƒ¼ãƒ çµ‚äº†ï¼';
                    const maxScore = Math.max(...Object.values(state.scores));
                    const winners = gameData.players.filter(p => state.scores[p.id] === maxScore);
                    if (winners.length > 1) { winnerText += `å‹è€…: ${winners.map(w => w.name).join(', ')} (å¼•ãåˆ†ã‘)`; }
                    else if (winners.length === 1) { winnerText += `å‹è€…: ${winners[0].name}`; }
                    status = winnerText;
                } else if (state.turn === userId) {
                    status = `ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’${2 - state.flippedIndices.length}æšã‚ãã£ã¦ãã ã•ã„ã€‚`;
                } else {
                    status = `${gameData.players.find(p => p.id === state.turn)?.name ?? ''}ã•ã‚“ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚`;
                }
                gameStatusMessage.textContent = status;
                if (state.flippedIndices.length === 2 && state.turn === userId) {
                    const card1 = state.boardCards[state.flippedIndices[0]];
                    const card2 = state.boardCards[state.flippedIndices[1]];
                    const rank1 = card1.cardString.split('_')[1];
                    const rank2 = card2.cardString.split('_')[1];
                    if (rank1 !== rank2) {
                        clearTimeout(clientSideTimer);
                        clientSideTimer = setTimeout(() => { GameManager.handleAction({ type: 'CHECK_PAIR' }); }, 1000);
                    }
                }
            },
            update: (gameData, action, playerId) => {
                let state = gameData.gameState;
                if (state.turn !== playerId) return gameData;
                if (action.type === 'FLIP_CARD') {
                    if (state.flippedIndices.length >= 2 || state.boardCards[action.index].isFaceUp) { return gameData; }
                    state.boardCards[action.index].isFaceUp = true;
                    state.flippedIndices.push(action.index);
                    if (state.flippedIndices.length === 2) {
                        const card1 = state.boardCards[state.flippedIndices[0]];
                        const card2 = state.boardCards[state.flippedIndices[1]];
                        const rank1 = card1.cardString.split('_')[1];
                        const rank2 = card2.cardString.split('_')[1];
                        if (rank1 === rank2) {
                            card1.isMatched = true; card2.isMatched = true; state.scores[playerId]++; state.flippedIndices = [];
                            if (state.boardCards.every(c => c.isMatched)) { gameData.status = 'finished'; }
                        }
                    }
                } else if (action.type === 'CHECK_PAIR') {
                    state.boardCards[state.flippedIndices[0]].isFaceUp = false; state.boardCards[state.flippedIndices[1]].isFaceUp = false;
                    state.flippedIndices = [];
                    shinkeisuijakuLogic.setNextTurn(gameData);
                }
                return gameData;
            },
            setNextTurn: (gameData) => {
                const state = gameData.gameState;
                const currentPlayerIndex = gameData.players.findIndex(p => p.id === state.turn);
                state.turn = gameData.players[(currentPlayerIndex + 1) % gameData.players.length].id;
            },
             handleLeave: (gameData, playerId) => {
                if(gameData.gameState.turn === playerId) { shinkeisuijakuLogic.setNextTurn(gameData); }
                return gameData;
            }
        };

        gameLogics.doubt = doubtLogic;

        // ã™ã¹ã¦ã®ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã‚’å‰²ã‚Šå½“ã¦
        for (const key in gameLogics) {
            if (gameLogics[key] === null) {
                const logic = window[key + 'Logic'];
                if(logic) gameLogics[key] = logic;
            }
        }


        window.onload = initialize;
    </script>
</body>
</html>

